<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Sat, 13 Jul 2013 12:38:08 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Book Review - Exploring Everyday Things with Ruby and R by Sau Sheong Chang</title>
      <link>http://zsoldosp.eu/2012/10/book-review-exploring-everyday-things.html</link>
      <pubDate>Thu, 25 Oct 2012 19:47:00 CEST</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[book review]]></category>
      <category><![CDATA[analysis]]></category>
      <category><![CDATA[simulation]]></category>
      <guid isPermaLink="false">http://zsoldosp.eu/2012/10/book-review-exploring-everyday-things.html</guid>
      <description>Book Review - Exploring Everyday Things with Ruby and R by Sau Sheong Chang</description>
      <content:encoded><![CDATA[
<div style="text-align: center;"><img alt="Book cover image" src="http://akamaicovers.oreilly.com/images/9781449315153/s.gif" title=""/>Â </div><br/>Disclaimer: I received a free (electronic) copy of this ebook (<a href="http://shop.oreilly.com/product/0636920022626.do">Exploring Everyday Things with Ruby and R by Sau Sheong Chang</a>) from <a href="http://oreilly.com/">O'Reilly</a> as part of the <a href="http://oreilly.com/bloggers">O'Reilly Blogger Review Program</a>, which also requires me to write a review about it. That aside, I would have purchased this book this year anyway, and would have reviewed it on this blog too.<br/><h2>About me and why I read this book</h2>I have been programming professionally for about 8 years, mainly business applications and reporting, so I already have quite some love for data. While I haven't used math much in my day jobs, I liked (and was good at) it in high school, including taking extra classes - so I have learned basic statistics. Refreshing and advancing my data analytics skills is one of my goals this year, and reading this book was part of that plan - I have heard that R is one of the most powerful languages for statistical analysis currently available.<br/><h2>About the book</h2>The book is written assuming basic understanding of programming and sets two goals: <br/><ul><li>to awaken the curiosity in the reader to go out and explore things and search for explanation, models, and experiments to validate understanding; </li><li>to show you some basic, but practical R and Ruby.</li></ul>While the author intended each chapter to be more or less self sufficient, I have found it to be better read sequentially, especially the simulation chapters.<br/><h3>Ruby</h3>I had no trouble with the code examples, even though I have only programmed about half an hour total in my life in Ruby. Beware that the only knowledge you gain about Ruby is the bare minimum required, so you'll have to put aside your thirst for complete understanding of the language and its ecosystem. If you need to have a proper understanding to work in a language (which I don't think is necessary), you are better off either reading a Ruby book first or using your favorite language to obtain the data - the code is easy to port.<br/><h3>Making me curious</h3>I have had a lot of wow/a-ha moments, both about the topics chosen for discussion as well as the math/algorithmic ideas. You may find that you disagree with some of the conclusion the author draws, and it is emphasized during the introduction that the goal of the book is not to convince you about these conclusions, but to demonstrate the journey from question to conclusion in order to equip you with tools to enable you doing the same. This is mostly achieved. <br/>I award extra bonus points for mentioning the limitations of the used analytical tools - I don't think I would trust any book/article/blog post which presents something without its downsides!<br/>Not all examples are exactly everyday (e.g.: an analysis of going to work by car vs. public transportation would have been more everyday than how to simulate the flocking of birds), but they cover a wide breath of topics. The processing and analysis of the data is always challenging enough, plus your general knowledge is expanded.<br/>One thing I was missing is a description of a really important part - being a layman, how do I go about finding which algorithms to use? While it isn't a book about Research 101, a description of the search process would have been great. You can of course always google, but when entering a new topic I find guided search helpful - which are some of the trick keywords, which sites to prefer/avoid, etc. On the other hand, enough methods are described that just properly learning and understanding them would make me a much better statistician already. Once done with that I could just fall back reading through the R packages and methods, hoping that if I have seen a word before it would emerge from my passive knowledge when I'm faced with a matching problem.<br/><h3>The R language</h3>The book does a solid job to help you get started. It demonstrates enough language features to enable to you experiment with it for work projects (e.g.: use MySql as a datasource, create packages, etc.); points out the R component/library hubs to look for community packages; and recommends further learning resources. <br/>The <a href="https://github.com/sausheong/everyday">code examples</a> are like most programming book snippets - procedural, (mostly) everything is located in a single method/script. Not a tangled-spaghetti mess that makes one despise it in legacy code, only it makes for a lower signal/noise ratio and requires more effort from the reader. Guess its a genre problem, so if you have read other programming books, you shouldn't have any problems with this one. <br/><blockquote>Technical comment: the ebook isn't formatted to play nice with the Kindle DX, and while in print the code block might be only broken between left &amp; right pages, on the kindle it makes for awkward read.</blockquote>The exposed APIs suggest that R is a bit too ceremonial for my taste, but that could be abstracted away for the project that warrants R's use. I have also used a number of visually great .NET UI third party components that were a pain to work with from a programmer's perspective, yet helped us create a great product. Plus things that feel alien first become second nature after enough practice, so it isn't a big deal. I plan to take a look at NumPy as well, and defer the decision whether to dive deeper into R (possibly via using <a href="http://www.dotnetrocks.com/default.aspx?showNum=813">F# 3.0 type providers for R</a>).<br/><h3>Overall</h3>The book hasn't left me in awe, but it didn't feel like a chore to read as some other books. I got the taste of R that I wanted when I picked up my copy to read. On top of that, I have learned about fun things, and it also added books to my reading (wish)list (e.g.: <a href="http://www.amazon.com/The-Grammar-Graphics-Statistics-Computing/dp/0387245448/">The Grammar of Graphics by Leland Wilkinson</a>, <a href="http://www.amazon.com/Armchair-Economist-Economics-Everyday-Life/dp/1451651732/">Armchair Economist by Stephen E. Landsburg</a>, and more). This is no definitive guide on R, but to wet your appetite and get you started, it is a good one I can recommend without reservations.]]></content:encoded>
    </item>
    <item>
      <title>Book Review - Programming Collective Intelligence by Toby Segaran</title>
      <link>http://zsoldosp.eu/2012/03/book-review-programming-collective.html</link>
      <pubDate>Thu, 01 Mar 2012 20:31:00 CET</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[machine learning]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[book review]]></category>
      <category><![CDATA[data mining]]></category>
      <guid isPermaLink="false">http://zsoldosp.eu/2012/03/book-review-programming-collective.html</guid>
      <description>Book Review - Programming Collective Intelligence by Toby Segaran</description>
      <content:encoded><![CDATA[
<div><img alt="Book cover photo" src="http://akamaicovers.oreilly.com/images/9780596529321/s.gif" style="float: left; margin: auto 20px 5px 20px"/> Disclaimer: I received a free (electronic) copy of this ebook (<a href="http://shop.oreilly.com/product/9780596529321.do">Programming Collective Intelligence by Toby Segaran</a>) from <a href="http://oreilly.com/">O'Reilly</a> as part of the <a href="http://oreilly.com/bloggers">O'Reilly Blogger Review Program</a>, which also requires me to write a review about it. That aside, I would have purchased this book this year anyway, and would have reviewed it on this blog too.</div><br/><h2 style="clear:left">About me and why I read this book</h2><br/><div>I've been programming professionally for ~7.5 years, mainly business applications and reporting, so I already have quite some love for data. While I haven't used math much in my day jobs, I liked (and was good at) it in high school, including taking extra classes - so I have learned basic statistics. Refreshing and advancing my data analytics skills is one of my goals this year, and reading this book was part of the plan.</div><br/><br/><h2>About the book</h2><br/><br/><div>The book introduces <a href="http://my.safaribooksonline.com/book/web-development/9780596529321?bookview=toc">lots of algorithms</a> that can be used to gain new insight into any kind of data one might come across. The explanations are broken up into digestible chunks, and are supported by great visualizations. While understanding of the previous chunks is required for the later ones, this allowed me to read through most of the book on the train to and from work.</div><br/><br/><div>Each of the algorithms is illustrated with real world application examples, and examples where applying them doesn't make sense are brought too. The exercises at the end of the chapters are applied and not purely theoretical - and coming up with exercises from the domain I work with every day was pretty easy! The book is really inspiring, which is great for an introductory book!</div><br/><br/><div>In addition to the well written, gradual introduction, the book has a concise algorithm reference at the end, so when one needs a quick refresher, there is no need to wade through the lengthy tutorials.</div><br/><br/><div>While the prose and the logic of the explanations are great, I have found the code samples hard to follow: <a href="http://www.codinghorror.com/blog/2006/05/code-smells.html">really short, cryptic variable names; leaky abstractions; inconsistent coding style</a> just to name a few. Some code samples are actually <a href="http://oreilly.com/catalog/errataunconfirmed.csp?isbn=9780596529321">incorrect implementations of the given algorithm</a> and there are antipatterns like <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">string sql concatenation</a> in the code without a warning comment to the reader to remind them it's a bad practice.</div><br/><br/><div>Nonetheless, it is great to have actual code to play with, just the initial reading and reviewing of it requires some extra effort.</div><br/><div>The book claims that you don't need previous Python knowledge to understand the code samples, which I can't confirm (I use Python at my day job), but I wouldn't be surprised if not knowing Python could make understanding the code even more difficult (I've actually learned a few new language features from the samples!). Also, the Python language has come a long way since 2.4, which is the version used in the book - and that old version makes the code feel dated.</div><br/><div>The book was written in 2007, but is not dated. First, the foundations of any topic tend to be timeless, and the most recent algorithm the book describes was published in 1990. The <a href="http://my.safaribooksonline.com/book/web-development/9780596529321?bookview=toc">Table of Contents</a> is comparable to more recently written ones (though I haven't read other introductory books yet).</div><br/><div>In summary: I would recommend it as a great introductory book!</div>]]></content:encoded>
    </item>
    <item>
      <title>Book Review - Python Testing Cookbook by Greg L. Turnquist</title>
      <link>http://zsoldosp.eu/2011/10/book-review-python-testing-cookbook-by.html</link>
      <pubDate>Sun, 23 Oct 2011 13:24:00 CEST</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[testing]]></category>
      <category><![CDATA[book review]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://zsoldosp.eu/2011/10/book-review-python-testing-cookbook-by.html</guid>
      <description>Book Review - Python Testing Cookbook by Greg L. Turnquist</description>
      <content:encoded><![CDATA[
<p>I have been doing (developer) automated testing for years now, but I recently moved from <a href="http://www.microsoft.com/net/">.NET</a> to <a href="http://www.python.org/">Python</a>. Recently, at one point I suggested to collegues that we try <a href="http://concordion.org/">Concordion</a>, only to learn that there is the <a href="http://docs.python.org/library/doctest.html"><code>doctest module</code></a> that could be used to achieve similar result (more about that in a later post). Remembering my own advice: <a href="http://www.blogger.com/2010/12/when-in-rome-do-as-romans-do.html">When In Rome, Do as the Romans Do</a>, I set out looking for a Python specific book about testing - and the <a href="http://www.packtpub.com/python-testing-cookbook/book">Python Testing Cookbook</a> by <a href="http://pythontestingcookbook.posterous.com/">Greg L. Turnquist</a> book seemed to be a good fit <a href="http://streamhacker.com/2011/07/18/python-testing-cookbook-review/">based on reviews</a>.</p><br/><hr/><br/><p>Overall, I liked the book, and it lived up to my expectations - it provided me with a list of tools and some sample code to get started with each of them. </p><br/><p>Beware that it is an entry level book - if, like me, you are already familiar with the testing concepts, and are looking for a book to learn about advanced testing concepts, theories, this book might be too little for you (or just read through the "There is more" sections of the recipies). But it is great for someone new to testing - though discussions with (and code reviews by) someone experienced in testing should accompany the reading.</p><br/><p>Despite the below criticisms, which are meant to be rather a companion to the book than an advice against it (i.e.: probably the only book I wouldn't find anything missing from and nothing to criticise about would be written for me, in real time, based on my immediate needs). The fact that the list is short shows how I found the rest of the book valuable, with great advices that go beyond the cookbook format (why you shouldn't use <code>fail()</code>, why there should be one assert per test, etc.). While I don't see eye to eye on each topic with the book, but just as the book is not written in a "my way or the highway" style, I will not get into minor differrences of opinion.</p><br/><h2>Format of the book</h2><br/><p>Each chapter explores a topic, with multiple specific recipes. Each recipe is relatively self contained, so if we are in a hurry and need to get to the solution of one specific problem without reading the whole book/chapter, it's possible. However, for those reading whole chapters, this results in a bit of repetition - I had to fight the urge to just gloss over the code I (thought) I had seen before. </p><br/><p>Each recepie follows the format of </p><br/><ul><br/><li>stating the problem</li><br/><li>showing code that solves it</li><br/><li>explaining how the code works</li><br/><li>and finally, providing warnings about pitfalls and problems in the code, and some further advice</li><br/></ul><br/><p>While this format is easy to follow, it has a few drawbacks.</p><br/><ul><br/><li>until I got used to this style, I often found myself cursing out loud like the <a href="http://www.osnews.com/story/19266/WTFs_m">code reviewers in this comic</a> while reading the code that will later be explained to be bad/antipattern. </li><br/><li>each recipe has a lot of additional testing insight, potentially unrelated to the tool being demonstrated - but one can miss these, thinking "oh, I know all about doctest, I'll just skip that chapter"</li><br/><li>for people in a hurry, just scanning the cookbook and copying (typing up) the code - there is nothing to indicate in the code that there is an antipattern there, only in the later paragrpahs - which you might not read when in a hurry. Just thinking about the examples where the unit tests have no asserts but only print statements gives me the shivers (and it's even used for illustration in the chapter about Continious Integration!).</li><br/></ul><br/><h2>What was missing from the book</h2><br/><ul><br/><li>About testing legacy code, I was missing two things: <ul><br/><li>a pointer to Michael Feather's classic book, <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a></li><br/><li>a warning about a mistake I have seen almost everyone (myself included) make when getting started with testing legacy code: don't write tests just because you can - only add cases for the area you are working on and only add enough to cover your current needs. This is hinted at, but I've found it's important to state it explicitly.</li><br/></ul><br/></li><br/><li>Notes about test maintainability <ul><br/><li>I strongly disagree with the approach of having one test class per physical class, and test methods directly excercising the class's method. I've found these can lead to maintainability problems down the road, so I prefer to introduce helper abstractions (e.g.: <code>assert_roman_numeral_conversion(expected_result, roman_numeral_string)</code> method) for most of my tests, and organize test methods by logical scenarios instead of mirroring code organizational units (on successful login, validating user input, etc.). These abstraction (indirections) makes it easier to update tests after an API change or refactoring. It might sound like an advanced topic, but I think it's a key concept for effective tests, and one that people should be exposed to early (just after they've made the mental jump from throwaway main methods with visual/human assertions to automated tests with automated assertions).</li><br/><li>Acceptance Testing - it is notoriously difficult for us programmers to <a href="http://blog.objectmentor.com/articles/2009/12/07/writing-maintainable-automated-acceptance-tests">write good acceptance tests</a> that are both maintainable and readable by the customers. I'm rather sure that in the example given in the book, the customers would not be interested in knowing which html tag contains the price in the output. </li><br/></ul><br/></li><br/></ul><br/><h2>Minor criticisms</h2><br/><ul><br/><li>there is an inconsistent level of detail and further pointers. E.g.: while <code>optparse</code> is explained in detail, <code>virtualenv</code> and <code>setuptools</code> are glossed over.</li><br/><li>In addition to the assertless test methods, the other thing that shocked me was the example in the doctest module that - to illustrate that the test works - introduced a bug in the test code. While the fact that test is code and thus can be buggy should be emphasized, but that wasn't the case here. This could leave the reader wondering why exactly we introduced the bug in the test code - aren't we testing the application?</li><br/><li>The book is careful not to fall into the trap of elitist speak that might alienate people, but saying that coupling and cohesiveness are subjective terms is just providing gunpowder to unwinnable arguments(*).</li><br/></ul><br/><h2>Interesting notes</h2><br/><ul><br/><li>This might be a cultural thing (I'm coming from .NET), but I've found it rather surprising that such an entry level book talks about test runners, and write custom test runners. It's useful knowledge, just something that I have not seen mentioned in so much detail in the Java/.NET world so early. Maybe it's got to do with IDEs being more widespread, where running a subset of the tests is easy.</li><br/></ul><br/><p>As said, the book lives up to the expectations, so if you would like to get a quick and practical introduction to testing in pytohn - both tools and concepts, I can recommend this one for you.</p><br/><hr/><br/><p>(*) Reminds me of a story from long ago. The team in question has decided to use bind variables for all SQL invocations (I've said it's been some time ago) to prevent SQL Injection. The one programmer wrote a stored procedure that concatenated the SQL command in its body... and argued that this is just a matter of style. At least the procedure was invoked from the application using bind parameters...</p>]]></content:encoded>
    </item>
  </channel>
</rss>
