<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Thu, 08 Aug 2013 05:31:47 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Own your data (or why did I move away from Blogger and WordPress?)</title>
      <link>http://blog.zsoldosp.eu/2013/08/04/own-your-data-or-why-did-i-move-away-from-blogger-and-wordpress/</link>
      <pubDate>Sun, 04 Aug 2013 14:25:00 CEST</pubDate>
      <category><![CDATA[blog]]></category>
      <category><![CDATA[outdoors]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[ownership]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">8UAjTLJV0td1NxR0DNBSZhVVots=</guid>
      <description>Own your data (or why did I move away from Blogger and WordPress?)</description>
      <content:encoded><![CDATA[<p>This blog used to be two separate blogs, hosted at 
<a href="http://blogger.com">Blogger</a> and <a href="http://wordpress.com">WordPress.com</a>,
respectively. I've gone through some trouble to migrate their content,
hopefully without breaking urls to this <a href="http://blogofile.com">Blogofile</a> 
based setup. In the process, I have lost a considerable number of 
features and conveniences - so why did I do this?</p>
<h2 id="owning-my-data-and-platform">Owning my data and platform</h2>
<p>As the saying goes, there is no such thing as a free lunch (or put more
bluntly, if you are not paying for it, <em>you</em> are the product being 
sold). A prime example is <a href="http://wordpress.com">WordPress.com</a>, which reserves the
right to display ads on your freely hosted blog, while <a href="http://blogger.com">Blogger</a>
probably enhances their advertisement profile of you - I don't know.</p>
<p>Even if these platforms don't do anything bad at the moment, they can
pretty much change the features available to you, or any other aspects
of their terms of service - remember that story about the 
<a href="http://news.cnet.com/8301-1023_3-57560370-93/instagram-rolls-back-terms-of-service-after-ownership-dustup/">Instagram ToS change regarding commercial use of your photos</a>?
Sure, it turned out to be a misunderstanding and/or they backed down,
but theoretically they can do it.</p>
<p>Of course, this wasn't a concern when I started out with blogging, but 
certainly is something to consider now that I am nearing post #42. </p>
<p>These considerations are of course applicable for other service 
providers beyond blogging, e.g.:</p>
<ul>
<li>(sports) tracking applications - while I have not yet gotten around 
  to building up a website like <a href="http://www.susi-ralf.de/index.html">Suzi &amp; Ralf</a>, but I know 
  eventually I will want to create something with the trails of all the
  places I've been to, whether for fun or for an anniversary gift or
  similar - and most sites make it rather hard to export your data 
  conveniently (<a href="http://endomondo.com">endomondo</a> is particularly annoying, so I'm 
  real grateful for the easy zip-export of <a href="http://runkeeper.com">runkeeper</a>!)</li>
<li>social networks - does <a href="http://linkedin.com">LinkedIn</a>, <a href="http://facebook.com">Facebook</a>, 
  <a href="http://xing.com">Xing</a>, etc. allow you to easily export your contacts and their
  contact details? I would be pretty upset to find myself without a 
  personal copy of that data</li>
</ul>
<p>Of course, I keep using services hosted by others, but I try to make 
sure I use one with a friendly <a href="http://www.dataliberation.org/">data liberation</a>
policy!</p>
<h2 id="other-considerations">Other considerations</h2>
<ul>
<li><strong>backup</strong> - sure, it's almost a repeat of the prior point, but worth 
  noting. It doesn't happen as often as before, but there is always the
  possibility of <a href="http://blog.theoldreader.com/post/56209408824/important-update">data loss or service outage</a></li>
<li><strong>version control</strong> - being a software developer, this is almost 
  second nature to me - it's incredibly liberating to be able to throw
  all my changes away and go back to a previous, known good version of
  a post draft.</li>
<li><strong>offline authoring</strong> - I do a lot of my writing and hobby coding 
  during my train commute, with spotty internet connection at best.
  Working locally on my laptop with my favorite text editor beats any
  online editor widget. </li>
<li><strong>full customizations</strong> - sure, probably there is a WordPress plugin
  for anything I would want to do, but for a lot of the small checks, 
  it takes longer to find, learn, and configure the one I need than
  to implement it in <a href="http://python.org">python</a> - e.g.: checking the site for
  broken links, custom reports, etc. I should probably mention the html
  template customizations here too, though you might be able to tell
  that is not yet the highest priority for me :)</li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>Some Metaprogramming (Reflection) In Bash</title>
      <link>http://blog.zsoldosp.eu/2013/07/25/some-metaprogramming-reflection-in-bash/</link>
      <pubDate>Thu, 25 Jul 2013 08:18:00 CEST</pubDate>
      <category><![CDATA[code]]></category>
      <category><![CDATA[metaprogramming]]></category>
      <category><![CDATA[bash]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">SrLBQ0AP18Vcd0lyROK5o6cmGI0=</guid>
      <description>Some Metaprogramming (Reflection) In Bash</description>
      <content:encoded><![CDATA[<p>I needed to write a function in bash that would set an environment 
variable to that value, unless the variable has been already set. 
This is a typical metaprogramming (reflection, introspection, etc.) 
task. </p>
<p>However, searching for the terms I know (reflection, metaprogramming) 
did not yield any bash results, since the bash terminology is <em>variable
variable</em> or <em>dereferencing</em>. I hope the title of this post will help
other non-native bash script writers searching for the "wrong" keywords!</p>
<p>The trick is the <code>${!&lt;variable name&gt;}</code> construct - it will be interpreted
as <code>${&lt;variable name's value&gt;}</code>. An example</p>
<pre><code>$ a="aaaaa"
$ b="bbbbb"
$ echo $a
aaaaa
$ echo $b
bbbbb
$ variable_name="a"
$ echo ${!variable_name}
aaaaa
$ variable_name="b"
$ echo ${!variable_name}
bbbbb
</code></pre>
<p>Of course, I could only find it offline (thanks, <a href="https://www.xing.com/profiles/Dieter_Loskarn">Dieter</a>!). 
Armed with this kowledge, the function itself becomes easy -</p>
<pre><code>function env_or_default() {
    name=$1
    default=$2
    if [[ ${!name} == "" ]]; then
        echo "no value set for $name, setting it to default value $default"
        export $name=$default
    else
        echo "value for $name was passed in from the environment, it's value is ${!name}"
    fi
}
</code></pre>
<p>Obviously, the <code>echo</code> lines are there just for illustration.</p>
<pre><code>$ env_or_default NOT_SET not-set-default-value
no value set for NOT_SET, setting it to default value not-set-default-value
$ export ALREADY_SET=already-has-value
$ env_or_default ALREADY_SET already-set-default-value
value for ALREADY_SET was passed in from the environment, it's value is already- has-value
$ echo $NOT_SET
not-set-default-value
$ echo $ALREADY_SET
already-has-value
</code></pre>
<p>Happy scripting! </p>
<p>P.S.: Krzysztof Wilczynski showed another <a href="https://gist.github.com/kwilczynski/5877621">trick to do 
this</a>:</p>
<pre><code>random_file_name() {
    local __return=$1
    eval $__return="'$(date +"$(basename -- "$0")_%s_${RANDOM}_$$")'"
}

random_file_name FILE_NAME
echo $FILE_NAME
</code></pre>]]></content:encoded>
    </item>
    <item>
      <title>Continuous Team Switching?</title>
      <link>http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</link>
      <pubDate>Sat, 19 Jan 2013 13:35:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</guid>
      <description>Continuous Team Switching?</description>
      <content:encoded><![CDATA[
<a href="http://douglassquirrel.com/">Douglas Squirrel</a> led <a href="http://www.citconf.com/wiki/index.php?title=Continuous_rewriting">a session at CITCON Budapest 2012 about Continuous Rewriting</a>, summarizing many ideas I've heard before from <a href="http://vimeo.com/43659070">Dan North</a> or <a href="http://forwardtechnology.co.uk/videos/32447325">Fred George</a> presentations into a really coherent evolutionary progression,  and took the concept even further. <br/><br/>Like other <em>Continuous</em> practices, this would be as much a  technical as an organizational-cultural change. It got me thinking about how this would change the team dynamics - not just inside a team, but in the context of the bigger organization.<br/><br/>The various <em>Continuous</em> practices always came about the realization that when something is rarely done, people will be bad at it and thus  it will be hard, ineffective and error prone. Thus if we simply do it  more often, we would get better at it.<br/><br/>Joining a new team and becoming an effective contributor is a process that is in need of improvement (on most teams). Getting to grips with the inherent domain complexity and the piled on technical complexity, learning the tricks and workarounds, etc. can hold back someone from being efficient for quite a while. On the other hand, having a fresh set of eyes can provide  a new perspective and expose much of the technical debt the team has.<br/><br/>All the continuous rewrite examples so far have reduced the code size, making it understandable (though often this reduction came thanks to better understanding of the domain).<br/><br/>Assuming the reduced code size enables speedier onboarding of new team members,  while still benefiting from the new perspective it brings, what would  more frequently rotating in and out rotation team members (while never completely  replacing any one team) result in?<br/><ul><li>Could this make spreading of ideas and practices within a company    more effective and faster than the current silo'd, departmental setups?</li><li>Would it speed up the on the job, just in time learning of every<br/>  developer in the company?</li><li>Would it improve the skill level of every developer, or would it   drag everyone down?</li><li>Would it strengthen the company culture, simply since each person    would know more other employees (given that many of us only socialize    within our own team)? </li><li>Would it spark more cross-departmental improvements - unlike    accountants or marketers, developers can jump between various areas    and domains of the company with relative ease, and thus could see    potential improvements. Would this make crazy IT processes (where the data   passes through, without enhancement, several different teams and applications,   modified effectively by only one at the middle, then be loaded back into    the original source) extinct, making IT governance easier?</li></ul>I don't know. But it certainly was a fun thought experiment! Feel free to add questions to the above list in the comments!
<hr><ol>
<li id="1">
    <strong><a href="http://www.odd-e.com">Steven</strong></a> on <em>2013/01/19 15:42:41</em>: There are studies found that stable teams can improve as long as 3 years. From that I would recommend stable teams over switching team members in and out.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/19 17:08:12</em>: Steve,<br/><br/>thanks for the input! Could you give some pointers for these studies (titles or links)?<br/><br/>I don't understand your second sentence (not a native English speaker) - you suggest that based on these studies, having a stable team is better/more effective/etc. than having constantly changing team members (the thought experiment of this post)?
</li></ol></li><li id="2">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/21 21:22:23</em>: Wow, this makes sense.<br/><br/>Let me add some anecdotal evidence: Every time I'm joining a team, I start to see tons of technical debt. Later I'm getting used to it. Sometimes I even miss the old code when switching to something new. This is the thing that makes _some_ outsourcing veterans (i.e. EPAM alumni) very efficient.
</li><li id="3">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/23 20:38:18</em>: what is the thing that makes outsourcing veterans efficient? The ability to enter any codebase and identify the place(s) that need changing for the new feature/project? <br/><br/>To add to the anecdotes (hoping @jasongorman doesn't read comments :)) - you don't need outsourcing for that, enough if you work on maintenance teams that are responsible for more than one application. Though it might be more a question of attitude and/or confidence than experience with switches. E.g.: I never hesitate to follow a stacktrace into 3rd party code (or find out why I *don't* have a stacktrace) or simply load the source to compensate the unhelpful documentation. Kind of like the difference between junior and senior developers is that the latter are not afraid to voice their opinions/questions...
</li><li id="4">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/29 19:37:44</em>: Didn't the blog just swallowed my comment? Here it is again:<br/><br/>What makes outsourcing veterans very efficient that they have to work with and maintain several projects written by other people. They will learn both continuously improve the code as well as do fuckin quick fixes. They also learn how to adapt to different coding styles they see in their project pool. They can relatively quickly identify the problematic parts of a codebase and they can come up with change suggestions. However, a typical outsourcing consumer isn't interested in their opinion.<br/><br/>It's worth to mention that outsourcing veterans only have a *chance* to learn all this stuff. They can also burn out due to the mind-numbing tasks they have to do.
</li></ol>
]]></content:encoded>
    </item>
    <item>
      <title>Global Day of Coderetreat 2012 - Nuremberg</title>
      <link>http://blog.zsoldosp.eu/2012/12/global-day-of-coderetreat-2012-nuremberg.html</link>
      <pubDate>Thu, 20 Dec 2012 09:30:00 CET</pubDate>
      <category><![CDATA[code]]></category>
      <category><![CDATA[organizing]]></category>
      <category><![CDATA[community]]></category>
      <category><![CDATA[code retreat]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/12/global-day-of-coderetreat-2012-nuremberg.html</guid>
      <description>Global Day of Coderetreat 2012 - Nuremberg</description>
      <content:encoded><![CDATA[
<br/><br/><header> <div id="global-day-of-coderetreat-2012-nuremberg"></div></header><div class="post_prose"><blockquote>If you are not familiar with the concept of a  <a href="http://coderetreat.org/">code retreat</a>, listen to this  <a href="http://www.dotnetrocks.com/default.aspx?showNum=728">podcast</a> (or read the  <a href="http://s3.amazonaws.com/dnr/dotnetrocks_0728_corey_haines.pdf">transcript</a>).</blockquote>As you may remember, I've attended <a href="/2012/09/my-first-code-retreat-legacy-code.html">my first code retreat earlier this year in Frankfurt</a>. One of the reasons for attending was  that I had a nagging thought throughout organizing <a href="http://citconf.com/budapest2012/">CITCON Budapest</a> that I should do something locally too, and a coderetreat sounded just like the perfect thing. So I've came back with enough enthusiasm from Frankfurt to approach our CEO (Dirk) about <a href="http://www.paessler.com/">Paessler AG</a> helping me organize one in Nuremberg - and he offered the office to host it in and to pay for the lunch. Thus  the biggest obstacle was cleared.<br/><blockquote>The importance of this couldn't be emphasized. As I've seen on the <a href="http://globalday.coderetreat.org/">Global Day of Coderetreat</a> organizers' list, it has caused some headache and  worry for fellow hosts. And in addition to the fiscal support, my  colleagues went way beyond anything I expected - our sysadmins arranging the required technical &amp; security infrastructure, running <a href="http://www.paessler.com/blog/2012/11/21/other/paessler-is-one-of-the-hosts-of-the-global-day-of-coderetreat">the GDCR event on the  company blog</a>, and even non-programmer colleagues offering to  come by Saturday to help with anything if needed.  Thank you all, you made it really easy! (by the way, <a href="http://www.paessler.com/company/jobs">Paessler is hiring!</a>)</blockquote>Anyhow, this post will not be about the organization process, but about what I have learned on this day as a co-facilitator &amp; participant about code and people.<br/><blockquote>Another big thanks goes to <a href="http://twitter.com/marcoemrich">Marco Emrich</a>, a seasoned coderetreat facilitator, who helped getting the event off the ground and helped me getting  started facilitating (thanks to <a href="https://twitter.com/NicoleRauch">Nicole</a> &amp; <a href="http://twitter.com/Ookami86">Johannes</a>  for introducing me to Marco!)</blockquote>The attendance was low (next time we'll schedule the start 30-60 minutes later), but I was surprised to learn how well the coderetreat functioned with so few participants. To ensure there is enough variety and that people have new pairs, we took turns with Marco coding (which we planned anyway in case of odd number of participants).<br/><h2 id="the-sessions">The Sessions</h2><ol><li>no constraints, getting familiar with the problem</li><li><a href="https://github.com/zsoldosp/zsoldosp-dotfiles/blob/master/bin/snippets/python/unitsofmeasure.py">no primitives</a> &amp; focus on the rules (fake out the world if needed at all)</li><li>Ping-Pong TDD &amp; naive implementation (with a switch at half time)</li><li>no conditional &amp; no mouse</li><li>baby steps</li><li>free to choose session</li></ol><h2 id="its-the-global-day-of-coderetreat">It's the <strong>Global</strong> Day of Coderetreat</h2>Even though we were only a few people here, it's been great to chat to the others elsewhere worldwide, saying hi to people doing exactly the same thing we do, just in various other  locations. While there were audio problems sometime, we didn't mind it. And next year we won't  bother with trying to schedule exact times for the calls, since we all will miss those times  anyway, but rather just rely on improvising video calls.<br/><h2 id="code-related-observations">Code Related Observations</h2><ul><li>It's really interesting to see other people programming. It is certainly not    something one gets to do during their day jobs (except maybe trainers, team leads, and mentors).   It is even more interesting to contrast the external observer's impressions/understanding   with the understanding of the people involved in the programming - the difference can be   huge. This might help understanding how many developers feel bosses/managers always misunderstand   their progress...</li><li>It's also interesting to track people across the different pairs and see whether    they bring their firm opinions (battle scars?) to each session or let go of them    to allow the opportunity to learn a different approach. This is not necessarily a bad    thing, but if you have plans to learn, beware of this and be explicit what you want to    learn - know whether you want to explore one idea and bounce it off/get it challenged by    many people or whether you want to simply see how others program and see if any of that    could be applicable to you. E.g.: it was pretty interesting to see how my F#/Scala inspired   ideas (case classes &amp; types) could be materialized in clojure. However, I have certainly   learned less about clojure than I would have had I let my partner do it as he would   in clojure natively (though the <em>no primitives</em> restriction was screaming   for types in my opinion).</li><li>We developers are really creative at finding (or at least looking for) loopholes in the   constraints. During the <em>no conditional</em> session one pair TDD'd a function returning a boolean   and claimed they had no conditionals in their code and were trying to convince us that   even the rest of the system wouldn't need conditionals to use this code... Or that returning   booleans is not an issue since they could refactor it into something that doesn't need to    return booleans once they get to the rest of the system... I'm certainly looking forward running    a <em>no return values allowed</em> session and see how people will circumvent that (and rationalize it   away)!</li><li>The longer you have worked with a tool/language, the more readily you accept and work around   its quirks. When we wanted to structure our tests the way we would describe <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">the four rules   of Conway's Game of Life</a> in writing (heading, then four subheadings, and then the concrete    examples under the subheadings) it didn't match RSpec's expectations at all. We agreed that both    structures (RSpec vs. the natural) make sense and we can understand how &amp; why RSpec evolved this way,   but we couldn't make it match the natural structure. This lead to a nice brief discussion about when    you want to deviate from standard tooling/processes and when one is better off following it.</li><li>Some people just can't put off the desire to finish the task. I will have to be conscious of this   in the future, and prod people more - e.g.: to ask whether this test &amp; app code meets their definition of   perfect.</li><li>Sometimes when things are hard, it is an indication that you are doing the wrong thing or solving the   wrong problem. E.g.: I wanted to write a test for our function to ensure that the function fails unless    it gets exactly 8 parameters (number of neighbors) but we were not supposed to use primitives. It felt   like enlightenment when my pair pointed out that there is nothing in the rules that mandate that requirement!</li><li><a href="http://www.infoq.com/presentations/TDD-as-if-You-Meant-It">TDD as if you meant it</a> is really hard unless both of you are good at the chosen   language. I assumed Ruby and Python are rather similar, but learned quickly it is not the    case. While we had great conversations during the session, and I've learned some interesting things about   Ruby, we have not made much progress with the actual constraint.</li><li>It seems most people work on their desktop machines/docking stations, and thus their laptop is   a secondary device, where they have not invested in their environments that much, and thus   the no mouse constraint is much harder (e.g.: having ReSharper installed at work, but not on   the personal laptop).</li></ul>... and I could go on much longer :) Certainly, the coderetreat format is great, and I enjoyed both programming and facilitating (though the fact my German is not strong enough makes it somewhat difficult),  and I'm sure we'll do more coderetreats in Nuremberg. So keep an eye out for it on the <a href="http://coderetreat.org/events/event/search?q=Nuremberg">coderetreat  site</a> or on the <a href="http://www.softwerkskammer.de/">Softwarekammer</a> events page.</div>
]]></content:encoded>
    </item>
    <item>
      <title>Book Review - Exploring Everyday Things with Ruby and R by Sau Sheong Chang</title>
      <link>http://blog.zsoldosp.eu/2012/10/book-review-exploring-everyday-things.html</link>
      <pubDate>Thu, 25 Oct 2012 19:47:00 CEST</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[book review]]></category>
      <category><![CDATA[analysis]]></category>
      <category><![CDATA[simulation]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/10/book-review-exploring-everyday-things.html</guid>
      <description>Book Review - Exploring Everyday Things with Ruby and R by Sau Sheong Chang</description>
      <content:encoded><![CDATA[
<div style="text-align: center;"><img alt="Book cover image" src="http://akamaicovers.oreilly.com/images/9781449315153/s.gif" title=""/> </div><br/>Disclaimer: I received a free (electronic) copy of this ebook (<a href="http://shop.oreilly.com/product/0636920022626.do">Exploring Everyday Things with Ruby and R by Sau Sheong Chang</a>) from <a href="http://oreilly.com/">O'Reilly</a> as part of the <a href="http://oreilly.com/bloggers">O'Reilly Blogger Review Program</a>, which also requires me to write a review about it. That aside, I would have purchased this book this year anyway, and would have reviewed it on this blog too.<br/><h2>About me and why I read this book</h2>I have been programming professionally for about 8 years, mainly business applications and reporting, so I already have quite some love for data. While I haven't used math much in my day jobs, I liked (and was good at) it in high school, including taking extra classes - so I have learned basic statistics. Refreshing and advancing my data analytics skills is one of my goals this year, and reading this book was part of that plan - I have heard that R is one of the most powerful languages for statistical analysis currently available.<br/><h2>About the book</h2>The book is written assuming basic understanding of programming and sets two goals: <br/><ul><li>to awaken the curiosity in the reader to go out and explore things and search for explanation, models, and experiments to validate understanding; </li><li>to show you some basic, but practical R and Ruby.</li></ul>While the author intended each chapter to be more or less self sufficient, I have found it to be better read sequentially, especially the simulation chapters.<br/><h3>Ruby</h3>I had no trouble with the code examples, even though I have only programmed about half an hour total in my life in Ruby. Beware that the only knowledge you gain about Ruby is the bare minimum required, so you'll have to put aside your thirst for complete understanding of the language and its ecosystem. If you need to have a proper understanding to work in a language (which I don't think is necessary), you are better off either reading a Ruby book first or using your favorite language to obtain the data - the code is easy to port.<br/><h3>Making me curious</h3>I have had a lot of wow/a-ha moments, both about the topics chosen for discussion as well as the math/algorithmic ideas. You may find that you disagree with some of the conclusion the author draws, and it is emphasized during the introduction that the goal of the book is not to convince you about these conclusions, but to demonstrate the journey from question to conclusion in order to equip you with tools to enable you doing the same. This is mostly achieved. <br/>I award extra bonus points for mentioning the limitations of the used analytical tools - I don't think I would trust any book/article/blog post which presents something without its downsides!<br/>Not all examples are exactly everyday (e.g.: an analysis of going to work by car vs. public transportation would have been more everyday than how to simulate the flocking of birds), but they cover a wide breath of topics. The processing and analysis of the data is always challenging enough, plus your general knowledge is expanded.<br/>One thing I was missing is a description of a really important part - being a layman, how do I go about finding which algorithms to use? While it isn't a book about Research 101, a description of the search process would have been great. You can of course always google, but when entering a new topic I find guided search helpful - which are some of the trick keywords, which sites to prefer/avoid, etc. On the other hand, enough methods are described that just properly learning and understanding them would make me a much better statistician already. Once done with that I could just fall back reading through the R packages and methods, hoping that if I have seen a word before it would emerge from my passive knowledge when I'm faced with a matching problem.<br/><h3>The R language</h3>The book does a solid job to help you get started. It demonstrates enough language features to enable to you experiment with it for work projects (e.g.: use MySql as a datasource, create packages, etc.); points out the R component/library hubs to look for community packages; and recommends further learning resources. <br/>The <a href="https://github.com/sausheong/everyday">code examples</a> are like most programming book snippets - procedural, (mostly) everything is located in a single method/script. Not a tangled-spaghetti mess that makes one despise it in legacy code, only it makes for a lower signal/noise ratio and requires more effort from the reader. Guess its a genre problem, so if you have read other programming books, you shouldn't have any problems with this one. <br/><blockquote>Technical comment: the ebook isn't formatted to play nice with the Kindle DX, and while in print the code block might be only broken between left &amp; right pages, on the kindle it makes for awkward read.</blockquote>The exposed APIs suggest that R is a bit too ceremonial for my taste, but that could be abstracted away for the project that warrants R's use. I have also used a number of visually great .NET UI third party components that were a pain to work with from a programmer's perspective, yet helped us create a great product. Plus things that feel alien first become second nature after enough practice, so it isn't a big deal. I plan to take a look at NumPy as well, and defer the decision whether to dive deeper into R (possibly via using <a href="http://www.dotnetrocks.com/default.aspx?showNum=813">F# 3.0 type providers for R</a>).<br/><h3>Overall</h3>The book hasn't left me in awe, but it didn't feel like a chore to read as some other books. I got the taste of R that I wanted when I picked up my copy to read. On top of that, I have learned about fun things, and it also added books to my reading (wish)list (e.g.: <a href="http://www.amazon.com/The-Grammar-Graphics-Statistics-Computing/dp/0387245448/">The Grammar of Graphics by Leland Wilkinson</a>, <a href="http://www.amazon.com/Armchair-Economist-Economics-Everyday-Life/dp/1451651732/">Armchair Economist by Stephen E. Landsburg</a>, and more). This is no definitive guide on R, but to wet your appetite and get you started, it is a good one I can recommend without reservations.]]></content:encoded>
    </item>
    <item>
      <title>My first Code Retreat - Legacy Code Retreat in Frankfurt on Sep 15, 2012</title>
      <link>http://blog.zsoldosp.eu/2012/09/my-first-code-retreat-legacy-code.html</link>
      <pubDate>Wed, 19 Sep 2012 19:44:00 CEST</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[code retreat]]></category>
      <category><![CDATA[legacy code]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/09/my-first-code-retreat-legacy-code.html</guid>
      <description>My first Code Retreat - Legacy Code Retreat in Frankfurt on Sep 15, 2012</description>
      <content:encoded><![CDATA[
<blockquote><p>If you are not familiar with the concept of a  <a href="http://coderetreat.org/">code retreat</a>, listen to this  <a href="http://www.dotnetrocks.com/default.aspx?showNum=728">podcast</a> (or read the  <a href="http://s3.amazonaws.com/dnr/dotnetrocks_0728_corey_haines.pdf">transcript</a>).</p></blockquote><p>While I knew about <a href="http://coderetreat.org/">Code Retreats</a> for a while, this  was the first I actually managed to attend). It was organized by the  <a href="http://www.softwerkskammer.de/">German Software Craftsmanship community</a> group, hosted by <a href="http://namics.com">Namics</a>, and facilitated by <a href="https://twitter.com/NicoleRauch">Nicole Rauch</a> and <a href="https://twitter.com/leiderleider">Andreas Leidig</a>. And it was great, thanks to everyone involved in putting up the event!</p><p>The <a href="http://www.coderetreat-rhein-main.com/learnmore-legacy">format has been described by others</a>, so I won't cover that. I have to say though that I really like the format and I wish I started socializing (in software related matters) first at a  code retreat instead of conferences or usergroups - the format of the  event guarantees one doesn't have to worry about uncomfortable silences to be filled with smalltalk. The day starts with coding, the retrospective is group talk, and with the exception of the lunch, the breaks are only five minutes long, and you are searching for the next programming pair  during that time anyway. Great way to get more comfortable interacting  with strangers about software! (And if you do want to socialize, just come early for breakfast and stay after the event).</p><h2 id="i_wonder_if_being_familiar_with_automated_testing_is_a_pre-requisite">I wonder if being familiar with automated testing is a pre-requisite</h2><p>My assumption is that one could attend a legacy code retreat even if  (s)he has no experience with automated testing, since</p><ul><li>You could learn the basics of testing from the pairs you are working   with</li><li>You can see it applied <em>in the real world</em>. The most common objection   I hear from people recently introduced to automated testing/TDD is that    it might work on greenfield projects, but cannot be applied on their    existing project</li></ul><p>So if you are (or know of someone who is) a person who attended such a  code retreat with no prior testing experience, please let me know - I  would love to know whether the above hypothesis matches your experience! Unfortunately all my pairs had prior experience, so it's still just a hypothesis.</p><h2 id="iteration_impressions_lessons_learned">Iteration impressions, lessons learned</h2><ul><li>Dynamic language IDEs still have a long way to go, so for now I'll    probably stick to Vim for python</li><li>While it's interesting to take a guided tour of a language you don't   know, the focus of the codebase is not on datastructures (only uses   lists/arrays) and thus you only catch a glimpse of the language. I'll   have to attend a normal code retreat to see whether this would be    different there</li><li>Giving a language demo is interesting, and you learn a lot about the   language too. People new to a language tend to ask questions about    things you take for granted, yet you may not know the answer to</li><li>Taking baby steps and not assuming anything is a Good Thing ™ - the   codebase is devious one, crafted with care to make you trip over. I.e.:   it is a proper legacy codebase, despite its small size!</li><li>The "never assume" advice holds especially as you move between    iterations. During one iteration we made a mistake that wasn't caught by    the regression tests. Since in the previous iteration (with another    pair) we had 100% (line) coverage, the fact that in the next    iteration we might not have that didn't occur to me...</li><li>Discipline is hard. I was totally carried away refactoring during the   last iteration. I had this craving to actually make progress with the   refactoring, and I caught myself saying things "were we responsible   coders, we would now stop to write some tests, but let's just move on   now", as well as tugging multiple pieces of the spaghetti at the same   time. While here I might be forgiven (after all, the last iteration    was a free to choose what to do (with) this codebase), it's an   important reminder that I should watch myself at work - I would have   never expected myself to get so off track in a matter of 10-15 minutes.   And I used to pride myself that I realize when I'm in a dead end and   have no trouble throwing away code to start from the last known good   state!</li><li>The code retreat format is great for teaching people the importance of   prototypes, I will keep that in mind for the future. During the    functional iteration we haven't made much progress, but on the train    home I did a quick experiment to start making it functional from the   outside in, starting at the main() method, introducing the GameState   as a subclass of Game, and each step returning a new GameState (while   still modifying the old game state, since the refactoring was    incomplete, as it usually is the case). This approach didn't occur to    me the first time, and had I not started from a clean slate, I would   not have thought of it if I were to continue where I left off the    previous attempt.</li><li>While the facilitators keep going around, we didn't always get deep    into the issues they commented on (e.g.: I think if the test case and    the test name express clearly the domain and the scenario, it is   totally fine to use a variable called <em>sut</em>, etc.). </li><li>However, there is a lot of time available to discuss with your pair,   not having to worry whether or not the code will be finished, which    is great. One caveat is that you do have a time limit on the    discussion, since you don't want to bore your pair and want to    actually write code, so you are forced to condense your thoughts.    Luckily, this limit is not as bad as <a href="https://twitter.com">twitter</a>'s</li><li>Theory vs. practice, a.k.a. talking the talk vs. walking the walk.    I've been guilty of this myself, describing how my ideal test case    would look like in theory, and what guiding principles I follow while   writing an actual test case. Then the pair politely points out that the    theory is great, but what we have here in the code is not a    manifestation of those principles...</li></ul><h2 id="the_iteration_i_wish_was_there_-_working_towards_a_change_request">The Iteration I wish was there - working towards a change request</h2><p>Each iteration had a different focus, and I assume that there isn't a static final (pun intended) list of possible restrictions and it evolves. So despite this being my first ever code retreat and being told that  these ideas wouldn't fit the format, I'm documenting them here, so that I can refer back to it after my next code retreats to see whether I still feel the same about these, since now I think they would be similar  restrictions like during the traditional code retreat when one is not  allowed to speak or use <em>if</em> statements in the code.</p><p>I really missed having a clear functional goal for the iterations, since one usually refactors legacy code when some new feature/enhancement is  needed - and it has a huge impact on how one approaches a refactoring.</p><p>One mistake I have (seen) made when working with legacy code is going on  a <strong>refactoring spree</strong>, touching parts of the codebase which  we don't  need to change. The danger of it is that we can easily code ourselves  into a corner for days and slip on the original delivery. If it ain't  broken, don't fix it (and this doesn't contradict the  <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">boyscout rule</a>). This issue has been exposed during the iterations, many of us refactored one part of the application that  wasn't business logic heavy, but was a low hanging fruit. While one  iteration wouldn't be enough time to finish testing that part, the  conversation around it (what test cases would be needed to provide  sufficient code coverage, what's the minimum refactoring we need to do  to achieve that, etc.).</p><p>I raised it during the final retrospective, and people agree it's an important aspect, but they suggested it's not fit for the format of the code retreat.</p><p>The other great benefit of having a clear goal is that they demonstrate how <strong>fragile</strong> the <strong>regression characterization tests</strong> can be. A  neat little change request to the core business logic would have left  us without the safety net again, and would have made us think back to  the previous iterations when we felt skipping writing a specific test  is safe. While everyone knows it, that doesn't mean we wouldn't fall  victim to it..</p><p>And if you prefer to see a concrete example, instead of just reading  through this abstract text, I have something like the <a href="http://anarchycreek.com/doubledawgdare-series/">Double Dawg  Dare</a> in mind.</p><h2 id="some_technical_notes_for_attending_a_code_retreat">Some technical notes for attending a code retreat:</h2><ul><li>doublecheck with the organizers what you'll need to attend. They    probably plan to send out a reminder/notification email before the   event, but I so rarely use my laptop in an online environment that   their notice was too late for me to actually prepare my laptop for   the event.</li><li>know your settings &amp; IDE. There are a ton of yaks to be shaved, and   many minutes have been wasted by setting things up. It doesn't take   away from the experience, but it did stress me a bit the first time</li><li><p>either know how to use git, or just create two copies of the codebase   so you can easily revert to a clean codebase after the sessions. We    had some problems with this.</p><p>git clean -x -f -n # remove -n to really remove them   git reset HEAD . # remove everything from the changelist in case you added it   git checkout -- . # revert everything below the </p></li><li><p>bring a USB stick, and if you are not using your own laptop during all    the sessions, make a copy of the golden master textfile onto it after    each of your sessions in a new programming language (my laptop was    only used during the first and the last iteration, so for the last we   had no sample output textfile we could work against, and it took some   time to obtain it.</p></li><li>bring your own keyboard and know how to change a mac/linux/windows    machine's keyboard layout (or install one). I have not been typing in    a number of sessions because of this (try typing on a German mac    keyboard, when you are used to windows US layout!)</li></ul><h2 id="in_summary">In Summary</h2><p>It's a great event, you meet great people, and I would be surprised if  you came away from a code retreat not having learnt anything new.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06671468907643091304">Adrian Bolboaca</strong></a> on <em>2012/09/21 10:44:14</em>: Thanks for the great write-up.<br/><br/>I have a kind of an answer for why I don't get to that session of change request. When I thought about the legacy code retreat and added a couple of sessions I wanted to have a more natural flow. I wanted to have this session also, sometimes in the end of the day. But as a facilitator I saw that the attendees do not really know the techniques so we are stuck into explaining the basics that they need in order to be able to handle a change request. During all the legacy code retreats I facilitated maybe the 7th iteration would have been the "change request constraint". <br/>I e-met Andreas and Nicole a couple early this year when we had a skype call about the legacy code retreat. Then I met them at the Socrates conference this year. I'm sure they are doing an excellent job as facilitators, and maybe they have some answers to this. My guess is that we need more legacy code retreats happening and only after a while when the attendees know better the basics we can start and introduce this session. Or maybe we can find together a solution on improving the current format.
<ol>
<li id="1-1">
    <strong><a href="http://pboop.wordpress.com/">pboop</strong></a> on <em>2012/09/23 16:44:45</em>: I agree with you. In my opinion a leagcy code retreat is about HOW to change the code not WHY or WHICH WAY in order to open room for a new requirement.<br/><br/>Every participant is free to let her/his imagination grow after (or even during) the retreat and play around with the code base, inventing new requirements and so on.
</li><li id="1-2">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/09/30 17:11:58</em>: Thanks for the comment and sorry for the late followup.<br/><br/>I didn't intend that section as a criticism for the facilitators. Since it can be misread, I would appreciate if you could point out where and how, so I can correct it to avoid anyone else misunderstanding my intent (re-reading my post didn't help, I'm afraid I have too much context about what I wanted to say).
</li><li id="1-3">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/09/30 17:12:58</em>: I don't know what the exact goal was behind creating the legacy coderetreat format. But I have always preferred learning not just a practice, but also its underpinning ideas and the limits of it. While I can practice refactoring on my own, there may not be someone around pointing out that not everything needs to be refactored. Both are important and have their places, and we seem to disagree about the latter. My thinking is influenced by seeing people (myself included) overdoing/overvaluing the latest pattern/practice they have came across (HelloWorldProxyFactoryImpl), without knowing the limits of their usefulness and knowing the difference between understanding something in theory versus doing that in practice - being told something is brittle/unreliable and understanding it on an intellectual level is very different from actually experiencing it. The latter tends to be easier to remember :)<br/><br/>But I might have fallen victim to offering a solution instead of raising a question. If the Nuremberg global code retreat will be a success, and there will be more following it, I'll be happy to immerse myself deeper into the code retreat community and see how I feel about this original idea after some time - one of the motivations for posting it was so that I can come back and revisit it later.
</li></ol></li></ol>
]]></content:encoded>
    </item>
    <item>
      <title>Book Review - Programming Collective Intelligence by Toby Segaran</title>
      <link>http://blog.zsoldosp.eu/2012/03/book-review-programming-collective.html</link>
      <pubDate>Thu, 01 Mar 2012 20:31:00 CET</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[machine learning]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[book review]]></category>
      <category><![CDATA[data mining]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/03/book-review-programming-collective.html</guid>
      <description>Book Review - Programming Collective Intelligence by Toby Segaran</description>
      <content:encoded><![CDATA[
<div><img alt="Book cover photo" src="http://akamaicovers.oreilly.com/images/9780596529321/s.gif" style="float: left; margin: auto 20px 5px 20px"/> Disclaimer: I received a free (electronic) copy of this ebook (<a href="http://shop.oreilly.com/product/9780596529321.do">Programming Collective Intelligence by Toby Segaran</a>) from <a href="http://oreilly.com/">O'Reilly</a> as part of the <a href="http://oreilly.com/bloggers">O'Reilly Blogger Review Program</a>, which also requires me to write a review about it. That aside, I would have purchased this book this year anyway, and would have reviewed it on this blog too.</div><br/><h2 style="clear:left">About me and why I read this book</h2><br/><div>I've been programming professionally for ~7.5 years, mainly business applications and reporting, so I already have quite some love for data. While I haven't used math much in my day jobs, I liked (and was good at) it in high school, including taking extra classes - so I have learned basic statistics. Refreshing and advancing my data analytics skills is one of my goals this year, and reading this book was part of the plan.</div><br/><br/><h2>About the book</h2><br/><br/><div>The book introduces <a href="http://my.safaribooksonline.com/book/web-development/9780596529321?bookview=toc">lots of algorithms</a> that can be used to gain new insight into any kind of data one might come across. The explanations are broken up into digestible chunks, and are supported by great visualizations. While understanding of the previous chunks is required for the later ones, this allowed me to read through most of the book on the train to and from work.</div><br/><br/><div>Each of the algorithms is illustrated with real world application examples, and examples where applying them doesn't make sense are brought too. The exercises at the end of the chapters are applied and not purely theoretical - and coming up with exercises from the domain I work with every day was pretty easy! The book is really inspiring, which is great for an introductory book!</div><br/><br/><div>In addition to the well written, gradual introduction, the book has a concise algorithm reference at the end, so when one needs a quick refresher, there is no need to wade through the lengthy tutorials.</div><br/><br/><div>While the prose and the logic of the explanations are great, I have found the code samples hard to follow: <a href="http://www.codinghorror.com/blog/2006/05/code-smells.html">really short, cryptic variable names; leaky abstractions; inconsistent coding style</a> just to name a few. Some code samples are actually <a href="http://oreilly.com/catalog/errataunconfirmed.csp?isbn=9780596529321">incorrect implementations of the given algorithm</a> and there are antipatterns like <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">string sql concatenation</a> in the code without a warning comment to the reader to remind them it's a bad practice.</div><br/><br/><div>Nonetheless, it is great to have actual code to play with, just the initial reading and reviewing of it requires some extra effort.</div><br/><div>The book claims that you don't need previous Python knowledge to understand the code samples, which I can't confirm (I use Python at my day job), but I wouldn't be surprised if not knowing Python could make understanding the code even more difficult (I've actually learned a few new language features from the samples!). Also, the Python language has come a long way since 2.4, which is the version used in the book - and that old version makes the code feel dated.</div><br/><div>The book was written in 2007, but is not dated. First, the foundations of any topic tend to be timeless, and the most recent algorithm the book describes was published in 1990. The <a href="http://my.safaribooksonline.com/book/web-development/9780596529321?bookview=toc">Table of Contents</a> is comparable to more recently written ones (though I haven't read other introductory books yet).</div><br/><div>In summary: I would recommend it as a great introductory book!</div>]]></content:encoded>
    </item>
    <item>
      <title>Inversion of Control for Continuous Integration</title>
      <link>http://blog.zsoldosp.eu/2012/01/inversion-of-control-for-continuous.html</link>
      <pubDate>Fri, 17 Feb 2012 20:36:00 CET</pubDate>
      <category><![CDATA[version control]]></category>
      <category><![CDATA[ioc]]></category>
      <category><![CDATA[continuous integration]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/01/inversion-of-control-for-continuous.html</guid>
      <description>Inversion of Control for Continuous Integration</description>
      <content:encoded><![CDATA[
<h1>Problem Description</h1><br/><br/><p>Our build structure is pretty stable, but the exact content of the steps varies as we discover more smoke tests that we'd like to add to, or when we rearrange the location of these checks.</p><br/><br/><p>The CI servers I've used made this a rather cumbersome process:</p><br/><br/><ul class="simple"><br/><br/><li>First, I have to leave my development environment to go to the build servers configuration of choice - most of the time it is a web interface, and for some it is a config file</li><br/><br/><li>I have to point and click, and if it's a shell script, I have to make my modifications without syntax highlighting (for the config files usually take the shell command to execute as a string, so no syntax highlighting)</li><br/><br/><li>If it's a web interface, I have (or had) no versioning/backup/diff support for my changes (config files are better in this aspect).</li><br/><br/><li>If it's a config file, then I need to get it to the build server (we version control our config files), so that's at least one more command</li><br/><br/><li>I need to save my changes, and run a whole build to see whether my changes worked, which is a rather costly thing.</li><br/><br/><li>Most places have only one build server, so when I'm changing the step, I either edit the real job (bad idea) or make a copy of it, edit it, and then integrate it back to the real job. Of course, integrating back means: copy and paste.</li><br/><br/><li>If the build failed, I need to go back to the point and click and no syntax highlighting step to fix the failures</li><br/><br/><li>Last, but not least, with web interfaces, concurrent modifications of a build step lead to nasty surprises!</li><br/><br/></ul><br/><br/><br/><br/><h1>Normal development workflow</h1><br/><br/><ul class="simple"><br/><br/><li>I have an idea what I want to do</li><br/><br/><li>I write the tests and code to make it happen</li><br/><br/><li>I run the relevant tests and repeat until it's working</li><br/><br/><li>I check for source control updates</li><br/><br/><li>I run the pre-commit test suite (for dvcs people: pre-push)</li><br/><br/><li>Once all tests pass I commit, and move on to the next problem</li><br/><br/></ul><br/><br/><p>Quite a contrast, isn't it? And even the concurrent editing problem is solved!</p><br/><br/><br/><h1>Quick'n'Dirty Inversion of Control for builds</h1><br/><br/><p>Disclaimer: the solution described below is a really basic, low tech, proof of concept implementation.</p><br/><br/><p>Since most build servers at the end of the day</p><br/><br/><ul class="simple"><br/><br/><li>invoke a shell command</li><br/><br/><li>and interpret exit codes, <tt class="docutils literal">stdout</tt>, <tt class="docutils literal">stderr</tt>, and/or log files</li><br/><br/></ul><br/><br/><p>we defined the basic steps (update from version control, initialize database, run tests, run checks, generate documentation, notify) using the standard build server configuration, but the non-built in steps (all, except the version control update and the notification) are defined to invoke a shell script that resides in the project's own repository (e.g.: under bin/ci/oncommit/runchecks.sh). These shell scripts' results can be interpreted by the standard ways CI servers are familiar with - exceptions and stack traces, (unit)test output, and exit codes.</p><br/><br/><br/><h1>Benefits</h1><br/><br/><ul class="simple"><br/><br/><li>adding an extra smoke test doesn't require me to break my flow, and I can more easily test my changes locally and integrating it back into the main build means just committing it to the repository, and the next build will already pick this up</li><br/><br/><li>I can run the same checks locally if I would like to</li><br/><br/><li>if I were to support a bigger team/organization with their builds, this would make it rather easy to maintain a standard build across teams, yet allow each of them to customize their builds as they see it fit</li><br/><br/><li>if I were to evaluate a new build server product, I could easily and automatically see how it would work under production load, just by:<ul><br/><br/><li>creating a single parameterized build (checkout directory, source code repository)</li><br/><br/><li>defining the schedule for each build I have</li><br/><br/><li>and then replaying the past few weeks/months load - OK, I still would need to write the script that would queue the builds for the replay, but it still is more effective than to run the product only with a small pilot group and then see it crash under production load</li><br/><br/></ul><br/><br/></li><br/><br/></ul><br/><br/><br/><h1>Shortcomings, Possible Improvements</h1><br/><br/><p>As said, the above is a basic implementation, but has served a successful proof of concept for us. However, our builds are simple:</p><br/><br/><ul class="simple"><br/><br/><li>no dependencies between the build steps, it is simply chronological</li><br/><br/><li>no inter-project dependencies, such as component build hierarchy (if the server component is built successfully, rerun the UI component's integration tests in case the server's API changed, etc.)</li><br/><br/><li>the tests are executed in a single thread and process, on a single machine - no parallelization or sharding</li><br/><br/></ul><br/><br/><p>All of the above shortcomings could be addressed by writing a build server specific interpreter that would read our declarative build config file (map steps to scripts, define step/build dependencies/workflows), and would redefine the build's definition on the server. By creating a standard build definition format, we could just as easily move our builds between different servers as we can currently do with blogs - pity Google is not a player in the CI space, so the <a class="reference external" href="http://www.dataliberation.org/">Data Liberation Front</a> cannot help :).</p><br/><br/><br/><h1>Questions</h1><br/><br/><p>Does this idea make sense for you? Does such a solution already exist? Or are the required building blocks available? Let me know in the comments!</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/21 14:55:14</em>: What we do at our build server is something similar to this:<br/><br/>We have ant steps defined, e.g. build, run checkstyle, run unit tests. We have different Hudson jobs for the same branch, one for each purpose.<br/><br/>Applying this environment for your scenario (tell me if I missed something from the problem) would look like this:<br/>- we could create a new job for the integration tests.<br/>- for changing the integration tests, we could write new tests and add them to the corresponding ant step. We could write the code and the ant xml in our favorite IDE. We could run them in our environment before committing it.<br/>- we can use the output of the build step in the same way we usually do. This is right now stop/go; but I think there are other ways to do this out there.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/21 19:41:11</em>: Yup, your example achieves the same purpose as what I described. I have used the shell script in this example because a) I haven't worked on java projects in ages and I forgot it exists b) we have a number of scripts (both shell and django runscripts/management commands as well) that we reuse <br/><br/>When you say multiple jobs, you mean for one project (branch) you have 4-5 jobs or one job with multiple parallel steps?
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/22 13:55:01</em>: When I say multiple jobs, we have 2 jobs for each branch. I don't know if we can make Hudson smarter - this is how the experts set it up initially, and nobody ever questioned it.<br/><br/>Having predefined scripts, as placeholders to invoke other scripts - that is poor-mans-ant: you have a layer of abstraction between the CI server and the scripts that are actually running. Say for instance, Hudson invokes the smoketest.sh, which invokes the low-level step, something like this:<br/><br/>#!/bin/bash<br/>compile.sh<br/>dist.sh<br/>run-unit-tests.sh<br/>check-login-ui.sh<br/>check-the-crazy-rollback-use-case.sh<br/><br/>So all you had to do would be add a new line to this shell/perl file.<br/><br/>Or, in perl (or python, whatever) you can add any other logic<br/>#!/usr/bin/perl<br/>if (system("dist.sh") != 0) {<br/>  exit;<br/>}<br/>if (system("run-unit-tests.sh") != 0) {<br/>  exit;<br/>}<br/>#...<br/><br/>Here you can add alternative and parallel flows too. A bit ugly, programmatic, but works. Even more, you can keep it clean if you keep the actual step's scripts and the flow's scripts in different files.<br/><br/>SoapUI is not a CI solution, but still, it's something similar as it's a testing tool. They suggest to use scripts in order to define custom logic between the test steps. http://www.soapui.org/Functional-Testing/controlling-flow.html
</li></ol>
]]></content:encoded>
    </item>
    <item>
      <title>There Is More To Clean Code Than Clean Code</title>
      <link>http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</link>
      <pubDate>Fri, 03 Feb 2012 20:29:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</guid>
      <description>There Is More To Clean Code Than Clean Code</description>
      <content:encoded><![CDATA[
<p><a href="http://blog.8thlight.com/uncle-bob/2012/01/20/Fecophiles.html">A post written by Uncle Bob</a> in January (I'm behind my reading list) offended me. I absolutely agree with Uncle Bob's analysis regarding the code itself, and I also prefer the refactored version, but I have a problem with insulting the programmer(s) reluctant to appreciate the change. </p><br/><p>We write code in programming <em>languages</em>, and there are different levels of proficiency in a language.</p><br/><p>As I'm currently learning a new spoken language, I'm painfully aware of this - initially I probably sounded like a caveman. The first impression you get about me is totally different depending on the language I speak - but I am the same person!</p><br/><p>The learning curve of a language is not smooth - the steepness between consecutive <a href="http://en.wikipedia.org/wiki/Common_European_Framework_of_Reference_for_Languages#Common_reference_levels">levels of proficiency</a> is different. Going from not speaking any German to speaking A1 (tourist) level was easy, getting the basic grammar required for the low intermediate (B1) level wasn't too bad, but to get my German to the level where my English is will take more effort than the sum of all my previous investments<sup>1</sup>.</p><br/><p>Since it is my third foreign language I'm learning, I have no difficulty accepting that the level I think I speak is higher than the level I actually speak. Because of that, whenever someone rephrases my sentences in proper German <sup>2</sup>, I start from the assumption that likely their version is better, even if I don't understand first why - and I take the effort to understand their reasoning <sup>3</sup>. I do that despite that I was of course convinced that when I spoke, I expressed my thoughts in the best possible way.</p><br/><p>However, I don't have much at stake - no ego to hurt, no reputation to loose, and the roles are clear: I'm the beginner, and the people around me are the more experienced ones. In a software team, the roles might not be so clear - I had told colleagues almost twice my age how they should write code after only a few weeks of working there. Bad idea. Since then, I have learned <em>not</em> to start improving the coding style of a team by rewriting the code they have written, and showing off how much better my version is. Rather, I wait until a situation arises when they don't mind having me demonstrate some code improvements. I demo it, and explain why I do it that way. In my experience, the second approach is more effective, though it doesn't have that instant satisfaction and relief the first provides.</p><br/><p>As the joke goes, you need only one psychologist to change a light bulb, but the light bulb has to want the change real bad. </p><br/><p><a href="http://pragprog.com/book/trevan/driving-technical-change">Driving Technical Change</a> is hard, because it requires a mental/cultural change, and that change has to come from the inside - but can be catalyzed from the outside of course<sup>4</sup>. But just forcing practices or ways of working on unwilling recipients generates resistance (e.g.: <a href="http://www.npr.org/blogs/money/2011/12/16/143846133/the-friday-podcast-how-office-politics-could-take-down-europe">the story of the EU technocrat appointed to recalculate the 2009 Greek budget</a>).</p><br/><p>I would like to see more <a href="http://ayende.com/blog/tags/reviews">public code reviews</a> and public refactorings (e.g.: <a href="http://softwarelifecycle.wordpress.com/2012/01/08/an-exercise-in-refactoring/">Andrew Parker</a>, <a href="http://anarchycreek.com/doubledawgdare-series/">GeePawHill</a>), but I would like to see <a href="http://ayende.com/blog/153697/a-meta-post-about-negative-code-reviews">less public judgement passing on people</a> at the lower proficiency levels of programming. </p><br/><hr/><br/><p><sup>1</sup> there is a great <a href="http://hanselminutes.com/301/learning-to-speak-another-language-with-zach-owens">Hanselminutes episode on learning a foreign language</a> if interested. Beware, it may contain programming!</p><br/><p><sup>2</sup> German readers might disagree, since most Germans I meet speak Frankish :)</p><br/><p><sup>3</sup> Which of course, is sometimes harder for natives to properly explain than for novices to ask questions pointing out the seeming irregularities of the grammar</p><br/><p><sup>4</sup> And we won't always be able to foster change in all environments (note: this does not mean the others are at fault for not changing!). The same programmer can be highly productive in one team, and be the one slowing down another team. There is nothing wrong with changing jobs after realizing we are a net loss to a given team.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/06 11:53:39</em>: "I had told colleagues almost twice my age how they should write code after only a few weeks of working there."<br/><br/>Once I did the same: I pointed out that although they wanted to write a super-fast app, writing 500-line long methods just won't work. I also pointed out that having the code polluted with //System.out.println() -s is bad, that they should use some sort of logger instead.<br/><br/>It was pretty obvious to me, even before I read the the Clean Code book. Still, I believe this is why I couldn't get along with the team, and this is why was fired in 2.5 months.<br/><br/>The other side of the coin is: sometimes you just don't want to wait until the bulb wants the change really bad.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/06 20:55:06</em>: Hi bridge,<br/><br/>so I'm not the only one who made that mistake :). And you are right - when there is a culture clash in a team, or we need something other than what's possible (e.g.: we mostly would like to learn from others to improve our tech skills, and not work on our soft skills to be able to teach them our - potentially limited - understanding), moving on to another places probably the best thing - even if on occassion it's a move forced on us!
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/07 10:28:50</em>: Sure, there must be a lot of us who made that mistake :)<br/>On the other hand, I was asked to review their code. But, as it turns out, programmers are almost as sensitive about their code as poets are about their poems.
<ol>
<li id="2-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:18:58</em>: Giving feedback is tricky territory and requires either a built up trust or a lot of discipline from the feedback giver - even if one knows on the analytically that it's about the code, and not about the merits of the coder, a misdirected WTF (e.g.: *Who* wrote this mess?! vs. Look at *what* a mess *this* is.) can push the recipient into the defensive, preventing any positive discussion about *the code*.<br/><br/>Even if we can at least laugh at it (and ourselves), it still hurts - Kyle Baley gives a wonderful description of the feeling at http://codebetter.com/kylebaley/2012/01/30/qa-a-hillbilly-love-story/ :)
</li></ol></li><li id="3">
    <strong><a href="None">r1tch</strong></a> on <em>2012/02/07 14:19:04</em>: I dare to agree with Uncle Bob. :) If someone is as junior to have problems understanding the refactored code, then he should know to shut up. In the story, the two colleagues claimed the original was to be easier to understand! This is obvious bullsh*t. The only thing I might (might!) allow for their help is to add comments in the isPzt() function, explaining what's happening, like:<br/>// an item is PzT if:<br/>// it's non-null, AND<br/>// has parent, AND parent is nfo or discontinued<br/><br/>However, a company is in serious trouble is such comments are needed. Or am I just too spoilt here...? :)
<ol>
<li id="3-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:36:10</em>: Hi r1tch, <br/><br/>Thanks for your input and I appreciate that you did not phrased it as "I disagree with you" :) I don't think I should speculate about your degree of spoiltness (is there such a word?) :)<br/><br/>I *strongly* disagree with the statement &gt;&gt;If someone is as junior to have problems understanding the refactored code, then he should know to shut up&lt;&lt; though. First, I don't think years of experience is any indicator of skill level in itself. Second, effective teams are the ones when there are no (at least technical) unasked questions, and noone has to "just accept" the right way (see also: Cargo Cult). <br/><br/>With regards to easier to understand code - it might be easier for you or for me to understand, but when you've lived with a codebase, you have developed a certain familiarity with it, just like you can almost blindly walk to the newspaper stand on the corner. However, if someone was to alter the pathways, move some billboards around, even if it might be better use of the space, you would first be uncomfortable with it. OK, it's not a perfect analogy, but I hope it conveys my meaning.<br/><br/>We are also missing a lot of context here - e.g.: I likely wouldn't ask my colleagues after a refactoring to see whether it was correct or not, since the tests would catch if I made a mistake. But if there are no test cases, and this code is in a central part of the codebase, I can understand why team members would be worry of the new, untested, unfamiliar code. Also, while I'm not sure how it is on that team, but if someone would respond to me in a way that is described as "willing to put up with my change to shut me up", I would ask myself whether I might be doing something wrong.<br/><br/>And I wouldn't put the kind of description you put into the comments, but rather into testcases :)
</li></ol></li></ol>
]]></content:encoded>
    </item>
    <item>
      <title>Find The Test Structure That Fits Your Team</title>
      <link>http://blog.zsoldosp.eu/2012/01/find-test-structure-that-fits-your-team.html</link>
      <pubDate>Thu, 12 Jan 2012 19:14:00 CET</pubDate>
      <category><![CDATA[documentation]]></category>
      <category><![CDATA[testing]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/01/find-test-structure-that-fits-your-team.html</guid>
      <description>Find The Test Structure That Fits Your Team</description>
      <content:encoded><![CDATA[
<p>A number of recent posts by <a href="http://haacked.com/archive/2012/01/02/structuring-unit-tests.aspx">Phil Haack</a>, <a href="http://ayende.com/blog/152897/structuring-your-unit-tests-why">Ayende Rahien</a>, and <a href="http://www.typemock.com/blog/2012/01/11/do-tests-get-too-much-respect/">Gil Zilberfeld</a> dealt with the topic of test organization. Each approach has its pros and cons, but neither is a silver bullet. Your (and your team's, project's) context determines which approach is right.</p><br/><p>Without aiming to provide an exhaustive list, below are some questions that have influence on test organization:</p><br/><ul><br/><li>Is the team in a consulting project where test documentation is required as part of delivery? </li><br/><li>Is it a product team? Is the firm in its early stage or is it mature like Oracle with mature products?</li><br/><li>What is the turnover rate of the team? What are the plans for its growth? The team might have all the knowledge in their head, but if it'll double in size in a year, then the communication value of tests could increase.</li><br/><li>What is the maturity level of the team? How long have they been working together?</li><br/><li>How closely and often do team members collaborate? </li><br/><li>Is there <a href="http://www.extremeprogramming.org/rules/collective.html">collective code ownership</a>?</li><br/><li>How does the team and its customers communicate? Some customers can - and willing to - read code, some need English (Turkish/Hungarian/German/etc.). Some teams have a level of (grown and deserved) trust that just saying the software works is accepted, some need a more formal acceptance and regression process.</li><br/><li>Is there proper IDE support for discoverability? Do all people reporting bugs (as tests) have access to that IDE? If not so, how do they find examples of how to write the bug-report test?</li><br/></ul><br/><p>Feel free to add more questions in the comments!</p>]]></content:encoded>
    </item>
  </channel>
</rss>
