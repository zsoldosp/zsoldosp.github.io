<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Sat, 02 Dec 2023 12:41:30 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Continuous Team Switching?</title>
      <link>http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</link>
      <pubDate>Sat, 19 Jan 2013 13:35:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</guid>
      <description>Continuous Team Switching?</description>
      <content:encoded><![CDATA[
          
<a href="http://douglassquirrel.com/">Douglas Squirrel</a> led <a href="http://www.citconf.com/wiki/index.php?title=Continuous_rewriting">a session at CITCON Budapest 2012 about Continuous Rewriting</a>, summarizing many ideas I've heard before from <a href="http://vimeo.com/43659070">Dan North</a> or <a href="http://forwardtechnology.co.uk/videos/32447325">Fred George</a> presentations into a really coherent evolutionary progression,  and took the concept even further. <br/><br/>Like other <em>Continuous</em> practices, this would be as much a  technical as an organizational-cultural change. It got me thinking about how this would change the team dynamics - not just inside a team, but in the context of the bigger organization.<br/><br/>The various <em>Continuous</em> practices always came about the realization that when something is rarely done, people will be bad at it and thus  it will be hard, ineffective and error prone. Thus if we simply do it  more often, we would get better at it.<br/><br/>Joining a new team and becoming an effective contributor is a process that is in need of improvement (on most teams). Getting to grips with the inherent domain complexity and the piled on technical complexity, learning the tricks and workarounds, etc. can hold back someone from being efficient for quite a while. On the other hand, having a fresh set of eyes can provide  a new perspective and expose much of the technical debt the team has.<br/><br/>All the continuous rewrite examples so far have reduced the code size, making it understandable (though often this reduction came thanks to better understanding of the domain).<br/><br/>Assuming the reduced code size enables speedier onboarding of new team members,  while still benefiting from the new perspective it brings, what would  more frequently rotating in and out rotation team members (while never completely  replacing any one team) result in?<br/><ul><li>Could this make spreading of ideas and practices within a company    more effective and faster than the current silo'd, departmental setups?</li><li>Would it speed up the on the job, just in time learning of every<br/>  developer in the company?</li><li>Would it improve the skill level of every developer, or would it   drag everyone down?</li><li>Would it strengthen the company culture, simply since each person    would know more other employees (given that many of us only socialize    within our own team)? </li><li>Would it spark more cross-departmental improvements - unlike    accountants or marketers, developers can jump between various areas    and domains of the company with relative ease, and thus could see    potential improvements. Would this make crazy IT processes (where the data   passes through, without enhancement, several different teams and applications,   modified effectively by only one at the middle, then be loaded back into    the original source) extinct, making IT governance easier?</li></ul>I don't know. But it certainly was a fun thought experiment! Feel free to add questions to the above list in the comments!
<hr><ol>
<li id="1">
    <strong><a href="http://www.odd-e.com">Steven</strong></a> on <em>2013/01/19 15:42:41</em>: There are studies found that stable teams can improve as long as 3 years. From that I would recommend stable teams over switching team members in and out.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/19 17:08:12</em>: Steve,<br/><br/>thanks for the input! Could you give some pointers for these studies (titles or links)?<br/><br/>I don't understand your second sentence (not a native English speaker) - you suggest that based on these studies, having a stable team is better/more effective/etc. than having constantly changing team members (the thought experiment of this post)?
</li></ol></li><li id="2">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/21 21:22:23</em>: Wow, this makes sense.<br/><br/>Let me add some anecdotal evidence: Every time I'm joining a team, I start to see tons of technical debt. Later I'm getting used to it. Sometimes I even miss the old code when switching to something new. This is the thing that makes _some_ outsourcing veterans (i.e. EPAM alumni) very efficient.
</li><li id="3">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/23 20:38:18</em>: what is the thing that makes outsourcing veterans efficient? The ability to enter any codebase and identify the place(s) that need changing for the new feature/project? <br/><br/>To add to the anecdotes (hoping @jasongorman doesn't read comments :)) - you don't need outsourcing for that, enough if you work on maintenance teams that are responsible for more than one application. Though it might be more a question of attitude and/or confidence than experience with switches. E.g.: I never hesitate to follow a stacktrace into 3rd party code (or find out why I *don't* have a stacktrace) or simply load the source to compensate the unhelpful documentation. Kind of like the difference between junior and senior developers is that the latter are not afraid to voice their opinions/questions...
</li><li id="4">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/29 19:37:44</em>: Didn't the blog just swallowed my comment? Here it is again:<br/><br/>What makes outsourcing veterans very efficient that they have to work with and maintain several projects written by other people. They will learn both continuously improve the code as well as do fuckin quick fixes. They also learn how to adapt to different coding styles they see in their project pool. They can relatively quickly identify the problematic parts of a codebase and they can come up with change suggestions. However, a typical outsourcing consumer isn't interested in their opinion.<br/><br/>It's worth to mention that outsourcing veterans only have a *chance* to learn all this stuff. They can also burn out due to the mind-numbing tasks they have to do.
</li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html">Continuous Team Switching?</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Dealing with crunch mode</title>
      <link>http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html</link>
      <pubDate>Sun, 31 Oct 2010 21:10:00 CET</pubDate>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[team]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html</guid>
      <description>Dealing with crunch mode</description>
      <content:encoded><![CDATA[
          
<div>Before going any further: I think that crunch mode is not sustainable and is best avoided. I won't analyze the phenomen or its causes, there has been <a href="http://www.infoq.com/news/2008/01/crunch-mode">much written about it</a>. However, given it definitely exists, though usually for shorter periods of time. Having had this experience a number of times, I felt I should organize my thoughts for future reference (for myself, and maybe for others too).</div><div><br/></div><div>Some of the points below might sound like good practice for software development in general - often we only start working on process problems after they've blown up into our face. <b><i>Holding <a href="http://en.wikipedia.org/wiki/Retrospective#Software_development">retrospectives</a></i></b> after such periods can bring quite a change, so don't miss out on the opportunity! However, we haven't even started yet, so let's step back in time.</div><div><br/></div><div><b><i>Knowing why</i></b> the close deadline is important from the beginning is crucial to keep the team motivated during this period. Working overtime for no apparent reason makes the already bad situation worse.</div><div><br/></div><div><b><i>Have well defined</i> </b>boundaries for both <b><i>time and scope</i></b>. This is generally a good practice, but this is a must - setting out on a death march without a clear purpose is unlikely to succeed. Break things down into small (4-8 hours) tasks, prioritize them (and I mean an ordered list, not making all of them into critical priority). If the added up estimates already run out of the possible available time,<b> <i>cut scope</i></b>. Most likely the only way it can be cut is vertical - e.g.: we will have logging, but we will work against only a single library, and won't make it pluggable for this deadline. Or we won't make the logging destination configurable (though it's a contrived example, it helps making the point).</div><div><div><br/></div><div><b><i>Taking on technical debt</i></b> can help. Be sure you all understand that this does not equal to crap code, unconditional copy-paste, etc..  Only introduce debt knowingly (you might want to keep an actual list of the shortcuts you have taken so you know what to fix in the upcoming releases).</div><div><br/></div><div><b><i>Stop experimenting</i></b> and move back to the comfort zone. Almost all projects involve some new element that the team is not familiar with it. If the team is just learning unit testing, they likely write the tests after they got the code to work, and are taking a long time to write them. In that situation, not writing tests for the time being could be the right choice. However, be careful to get the right message across - you are <b><i>not dropping the practice because it slows</i></b>development down, <b><i>but</i></b> only <b><i>rescheduling the learning period</i></b> to some other time. Also, just like with performance optimizations, make these decisions after measuring - <b><i>don't do it</i>based on speculation</b>.</div><div><br/></div><div>On the non-technical front, you can <b><i>cut back on meetings</i></b>, both in numbers and in duration. You might also want to schedule them so they don't interrupt the workflow. Have a status in the morning and at the end of the day, with a team lunch if more discussion is needed.</div><div><br/></div><div><b><i>Work from home</i></b>. Of course, some infrastructure is needed, and it might not be an option for everyone, especially for the person where next door is a construction site. However, saving on the commute time might could give you some extra time during the day without cutting too much into your personal life. Significant Others are more understanding if you are a bit more tired when they get to see you at least. </div></div><div><br/><hr/>[Scope section was updated based on <a href="http://twitter.com/#!/ljszalai/status/29308952267">@ljszalai's comment on twitter</a>]</div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html">Dealing with crunch mode</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Don't repeat yourself, even across platforms</title>
      <link>http://blog.zsoldosp.eu/2010/09/dont-repeat-yourself-even-across.html</link>
      <pubDate>Sun, 26 Sep 2010 12:57:00 CEST</pubDate>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[untested ideas]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/09/dont-repeat-yourself-even-across.html</guid>
      <description>Don't repeat yourself, even across platforms</description>
      <content:encoded><![CDATA[
          
<div>It's well known that duplication (not even mentioning triplication, quadruplication , etc.) is bad for maintainability (hence the <a href="http://c2.com/cgi/wiki?DontRepeatYourself">DRY principle</a>).  I have not seen much talk around DRY with regards to multiple platforms/programming languages, so this post is my attempt to distill my thoughts and to learn about the pros/cons of applying this principle across languages/platforms. </div><h2>Why would you use multiple platforms, or do a polyglot project?</h2><div>Without the goal of enumerating all possible reasons, some case are:<br/><ul><li>Web applications need the same input sanity validation performed both client side for usability (JavaScript) and server side (whatever technology you use) for security. The same argument can be made for any N-tier application for DTOs.</li><li>For a portfolio of applications in the same domain, there is a need for consistency  - e.g.: reference data catalog for input fields (you want to use the same terminology across the applications)</li><li>There can be similar logic applicable to different platforms - e.g.: some static code analysis is the same across platforms, whether or not we talk about Java or C# code, and it'd be nice to have just a single implementation.</li></ul></div><div><div><h2>Some approaches</h2><div><b>Meta data driven</b> libraries- the canonical data source is stored in some kind of a database, which contains a cross-platform implementation of the logic (e.g.: validation logic saved as regular expressions) and you have a minimal implementation in each language that is generic and data driven. There is minimal amount of code that your need to depend on in your application, which makes it a stable dependency (note I'm not talking about the code stored in the database, just the API you program against). However, the actual validation logic becomes black box from the testing perspective, and any of these metadata severely limits what you can do with it, and extension points are much harder to find - e.g.: should you want to restrict your application to only accept a certain range of zip code, how do you build that into a regexp based data driven validation framework? It certainly is possible, but hard, and in many cases expanding the framework  increases complexity with significantly, and the data dictionary becomes somewhat hard to maintain.</div><div><br/></div><div><b>Plain Old X Objects</b>* appeal more to me. They are easily debuggable, can be used in isolation and offline development. They can be much richer (you can have all the errors encountered reported back to the user rather than a pass/fail), more readable (though certainly you can <a href="http://www.codinghorror.com/blog/2008/06/regular-expressions-now-you-have-two-problems.html">write readable regular expressions</a>), and should you want to enhance/override the default behavior in special cases, you can easily override them. The problem of course is to make the same logic available on multiple platforms, in a unified fashion.</div><div><br/></div><div>If the technology stack allows it,  <b>pick a language that runs on all parts of the stack</b> (e.g.: Ruby/Python/JavaScript are all available as standalone and for the CLR/JVM.) The integration tests are fairly easy, just run the same tests with the different platforms.</div><div><br/></div><div>If there is no suitable bridge for the stack, <b>code generation</b> is one option, which is almost the same concept as the metadata driven simple framework above, just taking out the datastore and generating classes for each of the rules to enable offline usage, debugging, etc. This has the additional cost of creating and evolving the code generator tool in addition.</div><h2>Testing</h2><div>Irregardless of the path chosen, the shared logic must be tested and documented on all platforms, which might be hard to do. Acceptance testing tools (fitnesse, concordion, etc.) can help, or for the data driven tests (e.g.: for validation, input string, should be valid, expected error message) a simple testrunner can be created for each of the platforms. </div><div><div><h2>(Potential) Problems</h2><div><ul><li>Diversity vs. monoculture. The library becomes a single point of failure, and any bug has far reaching consequences. On the other hand, the reverse is true: any problem has to be fixed only once, and the benefits can be reaped by all that use the library. However, there might be fewer people looking at the shared domain for corner cases...</li><li>Shared dependency overhead - shared libraries can slow down development both for the clients of the library and the library itself. Processes for integration must be in place, etc. Gojko Adzic has a great post on <a href="http://gojko.net/2009/09/02/to-merge-or-not-to-merge-code-essentially-not-an-it-decision/">shared library usage</a>.</li><li>False sense of security - users of the library might assume that's all they need to do and not think through every problem so carefully. E.g.: DTO validation library might be confused with entity/business rules validation</li><li>Ayende has recently written a post about <a href="http://ayende.com/Blog/archive/2010/09/09/maintainability-code-size-amp-code-complexity.aspx">Maintainability, Code Size &amp; Code Complexity</a> that is (slightly) relevant to this discussion (<i><span class="Apple-style-span" style="font-size: small;">"The problem with the smaller and more complex code base is that the complexity tends to explode very quickly."</span></i>). In my reading the points are more applicable for the data-driven (or from there code generated) approach, where that smart framework becomes overly complex and fragile. Note he talks about a single application, and it's known that when dealing with a portfolio (NHProf, EFProf, etc.), he chose to  use a single base infrastructure.</li></ul></div><div><br/></div><div>Have you done something similar in practice? What are your thoughts and experiences? Or have you been thinking about this very same topic? What have I missed? What have I misunderstood? Let me know!</div><div><br/></div></div></div></div><div><br/></div><div>* <a href="http://www.martinfowler.com/bliki/POJO.html">http://www.martinfowler.com/bliki/POJO.html</a></div></div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/09/dont-repeat-yourself-even-across.html">Don't repeat yourself, even across platforms</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>On hiring programmers - writing code before the interview</title>
      <link>http://blog.zsoldosp.eu/2010/08/on-hiring-programmers-writing-code.html</link>
      <pubDate>Sat, 07 Aug 2010 11:42:00 CEST</pubDate>
      <category><![CDATA[hiring]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/08/on-hiring-programmers-writing-code.html</guid>
      <description>On hiring programmers - writing code before the interview</description>
      <content:encoded><![CDATA[
          
What prompted this post was <a href="http://weblabor.hu/munka/105931">this job ad</a> for an <a href="http://webfejleszto.netpositive.hu/">experienced web developer by Netpositive</a> and the discussions that it prompted -  and the realization that there is no way I can explain my view within <a href="http://twitter.com/">twitter</a>'s limitations.<br/><br/>I liked the ad because as a prerequisite for being invited to an interview, applicants are required to write a little web application (regularly read from an RSS feed, store it locally, display the posts on a page (with paging), and add Facebook's "like" functionality to the page).<br/><br/>Being able to conduct an interview based on code the candidate written at her own time before the interview has the following benefits:<br/><ul><li>the interview-fever problem is eliminated - some smart people can't solve simple problems during the interview they would be able to do in a minute under normal conditions<br/></li><li>those that can talk the talk but can't apply the theoretical knowledge to real problems don't get past this filter</li><li>those that cannot sell themselves during the interview but are good programmers can be considered<br/></li><li>as an interviewer, I can focus on what the candidate knows, can ask them to suggest ways to implement new features in an application they already familiar with<br/></li><li>it is more fair for people who might not know the jargon and terminology (though they certainly should learn it later), but are good at programming</li><li>you can learn a lot that might not be uncovered in a regular interview, e.g.: how likely the candidate is to reinvent the wheel rather than looking for existing solutions</li><li>the interviewer can screen applicants for requirement analysis if needed - just give an ambiguous enough spec<br/></li><li>those candidates, who just want to get <span style="font-style: italic;">a job</span> rather than <span style="font-style: italic;">a job at the given company</span> are likely not going to apply because of the extra effort required here. Some great candidates will not apply either; however, I think that is an OK risk to take.<br/></li></ul>The hardest thing with this approach is picking the problem to be solved -<br/><ul><li>should be big enough, not just a one off script, but something where some design is required, so the interviewers can learn about the candidate<br/></li><li>should be small enough so a good candidate can complete it in only a few hours;</li><li>should be a problem relevant to the job the opening is for, not another hello world program;</li><li>should be such that it's not a problem if it's googleable - we all google all the time, the important part that the candidate should demonstrate an understanding of the googled solution<br/></li><li>should obviously <span style="font-weight: bold;">not </span>be real work for the company - I would not want to apply to a company that wants to use my work for free to deliver to their customers.<br/></li></ul>I'm not even going to attempt to give a silver bullet solution that satisfies all the above, because - as everything in the software field - it depends on your context. However, the below ideas could be used as starting points:<br/><ul><li>problems from online programming competition archives, e.g.: <a href="http://uva.onlinejudge.org/">UVa Online Judge</a>, <a href="http://www.spoj.pl/">Sphere Online Judge</a>, etc.</li><li>dedicated online screening applications, like <a href="http://codility.com/">Codility</a></li><li>using tasks (bugfix, new features, etc.) from OSS projects. Yes, it is free work in a sense, but it contributes to the applicant's resume and makes the world a better place! :)<br/></li></ul>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06464815041802162050">DCifer</strong></a> on <em>2010/08/09 13:52:57</em>: Just as I mentioned on Twitter, that I'm strongly disagree with this concept. The main reason is time.<br/><br/>When searching for the right candidate I want to interview as much as I can. If I'm waiting for their application it gives a really extra overhead to check each solution. Most candidate will be hired by other companies, while I get to the end.<br/><br/>Just remember in college, how long did it take to receive the grade for your programming exercise.<br/><br/>Both candidate and worker on the same goal here. Get into position as fast as possible. If the Candidate found 10 interesting position and need to write 10 different application after the 4th all position will be closed until he got there.<br/><br/>Remember that these tests are no standards either. So one is want to see your knowledge in Hibernate other in Toplink, than some of them just in JPA. Or maybe a completely different area like JSF/JSP ...etc. It takes lot of effort to look after each one for each test.<br/><br/>To have a good programmer, there are certified tests. For example I had good experience with people having Sun JAVA certificates.<br/><br/>But the certificates actually worth nothing most of the time. The candidate will go through no matter what on a technical interview. Because we want to know we can work with him.<br/><br/>For example a candidate with really good programming skills still not fit, if he favour inheritance over delegation in a team, where every one is delegate type.<br/><br/>The write a program for our company only works in ideal environment. Where there is only one company to choose from, the company wants the candidate. The candidate wants the company. But this technique fails if there are many companies and many candidates on the market.<br/><br/>Just think about it. 11 candidates work 4 hour to create your test application, one is hired. 40 hour lost. As a candidate I would begin to think about, that the management does understand that the project requires both time and money. Many manager fail to understand, that even the employees receive standard salary the project still depend on the time resource.<br/><br/>But to be a little negative, actually I found cases where this is work. Mostly on outsourced companies, where the funds is not enough to hire highly skilled developers.<br/><br/>These companies are searching for candidates, which no other companies wants. Because the candidates on the wrong side of the Demand and Supply they can go through on long interview process. The usual process is to write a small application, which can be shown to the mother company that the candidate has some programming skills.<br/><br/>As the whole business not focus on completion, just do something which looks like IT, it is perfectly enough. During the interview process the company don't have to be afraid that the candidate taken away before the end. On the other side the candidates have the time as nobody bother him with other offers.<br/><br/>My experience is, that the number highly skilled IT professional is low. On the other hand the demand is high. It does happen very often, that when you finally found the right candidate the next day he is taken away.<br/><br/>If a company want to win the race for highly skilled programmers, he has to favour process, where he can interview as much as possible as fast as it can and a decide a quick as he can, or other better driven HR will take them away.
</li><li id="2">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2010/08/10 08:40:52</em>: @DCifer if I understood correctly, you raised mainly two problems, namely<br/><br/>1. it takes a long time to complete and evaluate a programming exercise, causing numerous problems for both sides<br/>2. you cannot cover everything in it - team fit, every technology/topic<br/><br/>Not covering everything in a single exercise isn't a problem, these problems - IMHO - are used as a filter instead of a CV to be called into the interview, when team fit and other aspects of the candidate can be evaluated.<br/><br/><br/>I don't have experience to make any comments on the supply/demand/quality argument, so I will not :)<br/><br/>Most jobs have an apply before date, so there is no race with time. If you want to apply to 10-20 companies (positions), then yes, this would take an awful lot of time, this process wants to bring in people who likely would like to work for *the* company, not work at *any* company as said. One goal of this process is to ensure that the ratio of quality applicants vs. all applicants should be high - not just technically, but from the point of view of how likely they are to accept an offer if made.<br/><br/>Sizing the problem is the key to ensure you get enough quality applications. But having such a problem might help you actually filter out 199 out of 200 - http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html , who won't even apply. <br/><br/>This process might loose great candidates who will not apply, as said in the original post, but that might not be the end of the world.<br/><br/>As for the company's side, evaluating the applications requires time from the company, but that's not wasted time in itself - reading and understanding code is a valuable skill, practicing that shouldn't hurt :)
</li><li id="3">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2010/09/29 23:43:58</em>: It was a pleasant surprise to find another programming contest with a potential hiring offer added on top of the normal pricing (sorry, Hungarian only) http://www.legjobbfejleszto.com/
</li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/08/on-hiring-programmers-writing-code.html">On hiring programmers - writing code before the interview</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
