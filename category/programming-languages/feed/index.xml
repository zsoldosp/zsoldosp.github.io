<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Sun, 15 Nov 2015 12:01:00 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Unit Testing In Elixir</title>
      <link>http://blog.zsoldosp.eu/2014/03/05/unit-testing-in-elixir/</link>
      <pubDate>Wed, 05 Mar 2014 19:30:00 CET</pubDate>
      <category><![CDATA[elixir]]></category>
      <category><![CDATA[testing]]></category>
      <category><![CDATA[programming languages]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">0o-82cbUaxJeza1AWri2hAjNJqg=</guid>
      <description>Unit Testing In Elixir</description>
      <content:encoded><![CDATA[
          <div class="document">
<p><em>Note that all of this was written at the time of Elixir
0.12.5-dev, so things might have changed since.</em></p>
<p>Since the <a class="reference external" href="http://elixir-lang.org/getting_started/ex_unit/1.html">tutorial</a>
covers the mechanics pretty well, this post is more about my
impressions of Elixir's approach to this topic.</p>
<div class="section" id="built-in">
<h1>Built-in</h1>
<p>Unit testing is built into the language and the tools, as well as the
tutorial - I love this approach. When you create a new project with
<tt class="docutils literal">mix</tt>, this is the output you get:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>mix new myproject
...
Your mix project was created successfully.
You can use mix to compile it, <span class="nb">test </span>it, and more:

    <span class="nb">cd </span>myproject
    mix compile
    mix <span class="nb">test

</span>Run <span class="sb">`</span>mix <span class="nb">help</span><span class="sb">`</span> <span class="k">for </span>more information.
</pre>
</div>
<div class="section" id="the-test-skeleton-is-not-beginner-friendly">
<h1>The test skeleton is not beginner friendly</h1>
<p>The skeleton unit test suffers the same problems like the <a class="reference external" href="http://djangoproject.com">Django</a>
equivalent - it is aimed at those who get unit testing already. If you
are new to automated testing, seeing code like</p>
<pre class="code elixir literal-block">
<span class="k">defmodule</span> <span class="no">FooTest</span> <span class="k">do
  </span><span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>

  <span class="n">test</span> <span class="s2">&quot;the truth&quot;</span> <span class="k">do
    </span><span class="n">assert</span><span class="p">(</span><span class="no">true</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>
<p>won't really make you say <em>&quot;yes, this makes me understand and love testing!&quot;</em>.
Granted, the whole Elixir tutorial is aimed at people who can already
program.</p>
</div>
<div class="section" id="simplified-yet-flexible-assertions">
<h1>Simplified, yet flexible assertions</h1>
<p>Unlike classic unit testing frameworks, which come bundled with
numerous <tt class="docutils literal">assertWhatever</tt> and <tt class="docutils literal">assertNotWhatever</tt> etc. methods,
(various overloads for each type), ExUnit mostly only uses <tt class="docutils literal">assert</tt> and
<tt class="docutils literal">assert_raise</tt> (though there are some more - see
<a class="reference external" href="http://elixir-lang.org/docs/stable/ExUnit.Assertions.html">ExUnit.Assertions</a>).
Rather, it relies on pattern matching and the assert macro being
smart enough to figure out how to provide a good (enough) failure
message - in this aspect, it reminds me of <a class="reference external" href="http://pytest.org/latest/">py.test</a></p>
<p>I'm curious to see whether it will stay this way - custom assertions
are superb for writing DSL-like code that experts can read (e.g.:
<a class="reference external" href="http://hamcrest.org/">Hamcrest</a>), and I really like the protocol-based extensibility
model used in Elixir elsewhere.</p>
</div>
<div class="section" id="constraint-of-the-failure-messages">
<h1>Constraint of the failure messages</h1>
<p>Your opinion of this feature might differ from mine, but it's worth
pointing this out. While the assertions are pretty flexible,
the actual error message will become the <strong>values</strong> on the left- and right
hand side of the pattern matching. This takes away the information of
exactly which method was called with what parameters, which
I have grown to rely on in Python. Consider the following tests and
the resulting failure messages - which one is more helpful?</p>
<p><a class="reference external" href="/snippets/unit_testing_with_elixir_gofl.exs">Elixir</a>:</p>
<pre class="code elixir literal-block">
    <span class="n">test</span> <span class="s2">&quot;survival - a living cell with 2 or 3 neighbours survives&quot;</span> <span class="k">do
        </span><span class="n">assert</span> <span class="no">Gofl</span><span class="o">.</span><span class="no">Rules</span><span class="o">.</span><span class="n">next_state</span><span class="p">(</span><span class="ss">:alive</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:alive</span>
        <span class="n">assert</span> <span class="no">Gofl</span><span class="o">.</span><span class="no">Rules</span><span class="o">.</span><span class="n">next_state</span><span class="p">(</span><span class="ss">:alive</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:alive</span>
        <span class="n">assert</span> <span class="no">Gofl</span><span class="o">.</span><span class="no">Rules</span><span class="o">.</span><span class="n">next_state</span><span class="p">(</span><span class="ss">:dead</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:alive</span>
        <span class="n">assert</span> <span class="no">Gofl</span><span class="o">.</span><span class="no">Rules</span><span class="o">.</span><span class="n">next_state</span><span class="p">(</span><span class="ss">:dead</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:dead</span>
    <span class="k">end</span>
</pre>
<pre class="code bash literal-block">
  1<span class="o">)</span> <span class="nb">test </span>survival - a living cell with 2 or 3 neighbours survives <span class="o">(</span>GoflRulesTest<span class="o">)</span>
     ** <span class="o">(</span>ExUnit.ExpectationError<span class="o">)</span>
                  expected: :alive
       to be equal to <span class="o">(==)</span>: :dead
     at unit_testing_with_elixir_gofl.exs:18



Finished in 0.05 seconds <span class="o">(</span>0.04s on load, 0.01s on tests<span class="o">)</span>
1 tests, 1 failures
</pre>
<p><a class="reference external" href="/snippets/unit_testing_with_elixir_gofl.py">Python</a>:</p>
<pre class="code python literal-block">
    <span class="k">def</span> <span class="nf">test_survival_a_living_cell_with_2_or_3_neighbours_survives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">,</span> <span class="n">cell_next_state</span><span class="p">(</span><span class="n">curr_state</span><span class="o">=</span><span class="n">ALIVE</span><span class="p">,</span> <span class="n">live_neighbour_cnt</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">,</span> <span class="n">cell_next_state</span><span class="p">(</span><span class="n">curr_state</span><span class="o">=</span><span class="n">ALIVE</span><span class="p">,</span> <span class="n">live_neighbour_cnt</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">ALIVE</span><span class="p">,</span> <span class="n">cell_next_state</span><span class="p">(</span><span class="n">curr_state</span><span class="o">=</span><span class="n">DEAD</span><span class="p">,</span> <span class="n">live_neighbour_cnt</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">DEAD</span><span class="p">,</span> <span class="n">cell_next_state</span><span class="p">(</span><span class="n">curr_state</span><span class="o">=</span><span class="n">DEAD</span><span class="p">,</span> <span class="n">live_neighbour_cnt</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</pre>
<pre class="code bash literal-block">
<span class="nv">F</span>
<span class="o">======================================================================</span>
FAIL: test_survival_a_living_cell_with_2_or_3_neighbours_survives <span class="o">(</span>__main__.GoflRulesTest<span class="o">)</span>
----------------------------------------------------------------------
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">&quot;unit_testing_with_elixir_gofl.py&quot;</span>, line 22, in test_survival_a_living_cell_with_2_or_3_neighbours_survives
    self.assertEquals<span class="o">(</span>DEAD, cell_next_state<span class="o">(</span><span class="nv">curr_state</span><span class="o">=</span>DEAD, <span class="nv">live_neighbour_cnt</span><span class="o">=</span>2<span class="o">))</span>
AssertionError: False !<span class="o">=</span> True

----------------------------------------------------------------------
Ran 1 <span class="nb">test </span>in 0.000s

FAILED <span class="o">(</span><span class="nv">failures</span><span class="o">=</span>1<span class="o">)</span>
</pre>
<p>Granted, Python is unique in this regard, IIRC I wouldn't get such
useful stacktraces in C# or Java either, but since I've been mostly
working in Python lately, it certainly was a surprise - not necessarily
for discouraging multiple assertions per test (it's a valid approach),
but more the hiding of the call site information.</p>
<p>However, since <tt class="docutils literal">assert</tt> itself is a macro, its technically possible
to change the assertion - added to my list of things to try :)</p>
</div>
<div class="section" id="async">
<h1>:async</h1>
<p>Test isolation is almost always hard, and these issues tend to only come
out from hiding once tests need to run in parallel for speed - good things
never come alone :) So having concurrent test running built in from the
start is a great way to have the one big (future) problem broken into
many minor inconveniences.</p>
<p>I also like that instead of a test runner command line switch, it is
declared on the TestCase level whether it's OK to run it in parallel
- giving finer control to the test author.</p>
<pre class="code elixir literal-block">
<span class="k">defmodule</span> <span class="no">GoflRulesTest</span> <span class="k">do
    </span><span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span><span class="p">,</span> <span class="ss">async:</span> <span class="no">true</span>
</pre>
<p>I just wish it was true by default!</p>
</div>
<div class="section" id="cool-things-i-would-like-to-explore-further">
<h1>Cool things I would like to explore further</h1>
<ol class="arabic">
<li><dl class="first docutils">
<dt>This short exploration hasn't allowed me figure what kind of</dt>
<dd><p class="first last"><strong>differences</strong> there are <strong>between</strong> testing <strong>functional</strong>-
and <strong>object oriented</strong> programs. My gut feeling is there
shouldn't be many: black box, transformation (state) based should
be the same. Interaction testing (mocking) seems an odd fit, however
it might just turn out to be as easy as passing in a &quot;mock&quot; function
as an argument.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Property-based testing</strong> has been on my radar for a while to be</dt>
<dd><p class="first last">tried - and its use seems to be more common in functional programming,
and it's appropriate I should try it in a context where it's set up
to succeed. This is when I'm thankful for Elixir being
built/run on top of a mature platform - otherwise there wouldn't yet
be an available library.</p>
</dd>
</dl>
</li>
</ol>
</div>
</div>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2014/03/05/unit-testing-in-elixir/">Unit Testing In Elixir</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>What Elixir Taught Me About Java - Method Overloading Is Just a Convention</title>
      <link>http://blog.zsoldosp.eu/2014/02/08/what-elixir-taught-me-about-java-method-overloading-is-just-a-convention/</link>
      <pubDate>Sat, 08 Feb 2014 15:10:00 CET</pubDate>
      <category><![CDATA[programming languages]]></category>
      <category><![CDATA[elixir]]></category>
      <category><![CDATA[oop]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">4mQOP4Y091_HZpmnEdjhq0LThyc=</guid>
      <description>What Elixir Taught Me About Java - Method Overloading Is Just a Convention</description>
      <content:encoded><![CDATA[
          <div class="document">
<p>I was struggling to understand <a class="reference external" href="http://stackoverflow.com/questions/18011784/why-are-there-two-kinds-of-functions-in-elixir/18023790#18023790">the differences between anonymous
and named functions</a>
in Elixir - only to eventually realize that a lot of it is due
to the incorrect mental model I had about <a class="reference external" href="https://en.wikipedia.org/wiki/Method_overloading">method overloading</a>
from before.</p>
<p>As the saying goes, <em>&quot;for every hard problem, there is a logical, yet
completely wrong explanation&quot;</em>.</p>
<div class="section" id="examples-of-function-arity-overloading">
<h1>Examples of function arity overloading</h1>
<p><em>Arity is just the term used to refer to the number of arguments the
function has.</em></p>
<p><strong>Java</strong></p>
<pre class="code java literal-block">
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodOverloadingArity</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">join</span><span class="o">(</span><span class="n">String</span> <span class="n">a</span><span class="o">,</span> <span class="n">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">join</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="s">&quot; &quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">join</span><span class="o">(</span><span class="n">String</span> <span class="n">a</span><span class="o">,</span> <span class="n">String</span> <span class="n">b</span><span class="o">,</span> <span class="n">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%s%s%s&quot;</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">sep</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
<p><strong>Elixir</strong></p>
<pre class="code elixir literal-block">
<span class="k">defmodule</span> <span class="no">MethodOverloadingArity</span> <span class="k">do

    def</span> <span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do
        </span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span> <span class="k">do
        </span><span class="n">a</span> <span class="o">&lt;&gt;</span> <span class="n">sep</span> <span class="o">&lt;&gt;</span> <span class="n">b</span>  <span class="c1"># string concatenation</span>
    <span class="k">end</span>

<span class="k">end</span>
</pre>
</div>
<div class="section" id="my-wrong-mental-model">
<h1>My wrong mental model</h1>
<p>I was thinking that since in interviews, tutorials, etc. method
overloading always comes up, there must be something special about it.
It makes for dynamic dispatch - which gets bound at compile time in
regular Java, but when invoked dynamically, it will resolve to the
appropriate overload. I.e.: the following pseudocode would be valid:</p>
<pre class="code elixir literal-block">
<span class="n">foo</span> <span class="o">=</span> <span class="no">MethodOverloadingArity</span><span class="o">.</span><span class="n">join</span>
<span class="n">foo</span><span class="o">.</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">foo</span><span class="o">.</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot; - &quot;</span><span class="p">)</span>
</pre>
<p>You can tell just from the heading that of course, it's is not valid.
And this is what we get from Elixir:</p>
<pre class="literal-block">
** (UndefinedFunctionError) undefined function: MethodOverloadingArity.join/0
    MethodOverloadingArity.join()
    MethodOverloadingArity.exs:13: (file)
    (elixir) src/elixir_lexical.erl:17: :elixir_lexical.run/2
    (elixir) lib/code.ex:301: Code.require_file/2


</pre>
<p>In the language, the functions are only unique with the combination of
the function name and the number of arguments - it fails because it
cannot find an overload which takes 0 arguments. Thus at the time I
store a reference to it in a variable, I have to resolve the arity.</p>
<p>Initially I thought it's just a special behavior for Elixir (Erlang),
so I set out to explore how it works in Java</p>
<pre class="code java literal-block">
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.IllegalArgumentException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodOverloadingMain</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&quot;MethodOverloadingArity&quot;</span><span class="o">);</span>
        <span class="n">Method</span><span class="o">[]</span> <span class="n">declaredMethods</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">declaredMethods</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">!=</span> <span class="s">&quot;join&quot;</span><span class="o">)</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="s">&quot;second&quot;</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;... invocation result (2 args): %s\n&quot;</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;... (2 args) %s\n&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="s">&quot;second&quot;</span><span class="o">,</span> <span class="s">&quot; - &quot;</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;... invocation result (3 args): %s\n&quot;</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;... (3 args) %s\n&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>(<em>Yes, it reminds me how much more elegant metaprogramming is in Python.
But Python has no method overloading</em>)</p>
<p>To my surprise (though in retrospect, it's obvious), arity also plays a
role in identifying methods in Java - notice how there are two methods
returned:</p>
<pre class="literal-block">
public static java.lang.String MethodOverloadingArity.join(java.lang.String,java.lang.String)
... invocation result (2 args): first second
... (3 args) java.lang.IllegalArgumentException: wrong number of arguments
public static java.lang.String MethodOverloadingArity.join(java.lang.String,java.lang.String,java.lang.String)
... (2 args) java.lang.IllegalArgumentException: wrong number of arguments
... invocation result (3 args): first - second

</pre>
<p>So in Java function overloading works the exact same way as it does in
Elixir (and based on my quick hallway research, in most other languages)
- an actual method is only identified by its name and arity (and in typed
languages, by type). Thus there is no dynamic method invocation based on
just its name.</p>
<p>So method overloading is just a convention, or if you wish to call it, a
hack.  I wish I learned of name and arity instead of method overloading
first!</p>
<p><em>This is yet another example why learning other languages benefits you even
if you won't end up using the new language in your day job!</em></p>
<p>With regardso to using method overloading, I think I prefer the Ruby/Python
approach - one name, one function, period. For most usecases, default argument
values allow for enough flexibility, and prevent abuse of this convention
(giving two wildly different implementations for the various overloads).</p>
<p><em>Disclaimer</em>: of course, I might still be entirely wrong. If so, please let
me know!</p>
<p>Also, I would like to thank <em>chrismccord</em>, <em>josevalim</em>, and <em>ericmj</em> from
the <cite>#elixir-lang</cite> IRC channel for patiently putting up with me and
helping me understand all this.</p>
</div>
</div>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2014/02/08/what-elixir-taught-me-about-java-method-overloading-is-just-a-convention/">What Elixir Taught Me About Java - Method Overloading Is Just a Convention</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Why I chose Elixir to learn this year (and initial impressions)</title>
      <link>http://blog.zsoldosp.eu/2014/01/31/why-i-chose-elixir-to-learn-this-year-and-initial-impressions/</link>
      <pubDate>Fri, 31 Jan 2014 11:46:00 CET</pubDate>
      <category><![CDATA[elixir]]></category>
      <category><![CDATA[programming languages]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">_J8kM8aoHGnkBPYQ285TytaSHOE=</guid>
      <description>Why I chose Elixir to learn this year (and initial impressions)</description>
      <content:encoded><![CDATA[
          <p>Because I liked the color. Just kidding - but I didn't invest too much
time into making the choice - though I'm sure that all the things I read
or heard during this past year influenced me.</p>
<p>It quickly boiled down to <a href="http://golang.org/">Go</a> or <a href="http://www.elixir-lang.org/">Elixir</a></p>
<p>Elixir won because:</p>
<ul>
<li><a href="https://youtu.be/hht9s6nAAx8">Prag Dave recommends it</a></li>
<li>I wanted to finally follow through on a functional language (
  I've played with <a href="http://www.scala-lang.org/">Scala</a> and <a href="http://fsharp.org/">F#</a> before, but
  somehow I didn't fall in love)</li>
<li>For one reason or another I never got excited about <a href="https://www.ruby-lang.org/en/">Ruby</a>, 
  but people keep telling me how nice its syntax is, and Elixir's
  is inspired by Ruby's, so I should get a taste. And semicolons are
  not required!</li>
<li>it's running on the Erlang VM, which seems to be quite different
  from the things I've used in the past</li>
</ul>
<h2 id="first-impressions">First impressions</h2>
<p>So far, I haven't yet finished the second page of the <a href="http://elixir-lang.org/getting_started/1.html">tutorial</a>,
have solved the first few <a href="https://projecteuler.net">Euler problems</a>, subscribed to the 
<a href="http://groups.google.com/group/elixir-lang-talk">elixir-talk</a> mailing list, and have asked for help on the IRC
channel. So I'm quite at the beginning.</p>
<p>Some of the things that were a "culture shock" or at least 
unexpected/confusing for me were:</p>
<ul>
<li>To quit the REPL (<code>iex</code>), one has to do <code>CTRL-C</code>. Not <code>CTRL-D</code>, 
   or type exit. Since at first I didn't read the startup message,
   I had the "get me out of here" desperation first time <a href="http://www.vim.org/">Vim</a>
   users are famous for.</li>
<li>Different types require different pattern matching - 
  <code>{head | tail } = {1, 2, 3}</code> does not work, it only works on lists
  <code>[head | tail ] = [1, 2, 3]</code>.</li>
<li>Operators that should be the same are not. For concatenating strings,
   you use <code>&lt;&gt;</code>, but for joining two lists, you use <code>++</code>. My python
   roots rebel - even if this likely provides helpful type
   hints once I'm familiar with it</li>
<li>Strong (<code>and</code>, <code>or</code>, and <code>not</code>) and weak (<code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>)
   boolean comparisons. I'm quite afraid of the mistakes I'll go,
   not realizing whether I check for strict boolean values or just 
   against <code>nil/false</code>. Scary...</li>
<li>Unlike in Python, the REPL (<code>iex</code>) and the script executor (<code>elixir</code>)
   are two separate commands.</li>
<li>There are no semicolons alright, but there are too many <code>end</code>s required
   for my taste. Python did spoil me in this aspect...</li>
<li>Blocks need to be parenthesized properly otherwise some nasty surprises
   happen, e.g.: <code>is_number if true do 1 + 2 end</code> is parsed as
   <code>is_number(if true) do 1 + 2 end</code></li>
<li>Pattern matching is powerful on one hand, but quite limited in others.
   Probably once I understand how it works, I won't try to do things like<br>
   <code>a = 1</code><br>
   <code>(^a + 1) = 2</code><br> as match. Though I'm still curious why
   <code>^a = (2 - 1)</code> works</li>
<li>Guard clauses - probably the list of what you can and cannot do is due
   to some Erlang VM internals, but I dislike memorizing things...</li>
<li>Maybe it's too early for me to read <a href="https://github.com/elixir-lang/elixir/blob/master/CHANGELOG.md#v0123-dev">release notes</a> - reading
   "The list <code>[1, 2, three: :four]</code> now correctly expands to 
   <code>[1, 2, {:three, :four}]</code>" makes me feel again that I have to be super
   careful when reading code...</li>
</ul>
<p>But there are really nice and fun moments, such as:</p>
<ul>
<li>The installation was easy - thanks to <a href="http://devblog.avdi.org/2013/07/05/installing-elixir-on-ubuntu-13-04/">Avdi Grim's post</a>.</li>
<li>I was able to quickly understand the structure of the exceptions -
   the &lt;function name&gt;/&lt;N&gt; refers to the number of arguments
   of the function.</li>
<li>Nice utf support - though since all strings are bytes, I have to keep
   this in mind for pattern matching - <code>&lt;&lt;f, rest :: binary&gt;&gt;</code> matches
   differently from <code>&lt;&lt;f :: utf8, rest :: binary &gt;&gt;</code>. So maybe this belongs
   to the above list :)</li>
<li>I love how anonymous functions can be turned into full blocks, unlike in
   Python.</li>
<li><code>fib = Stream.unfold({0, 1}, fn {a, b} -&gt; {a, {b, a + b}} end)</code></li>
<li><code>#elixirlang</code> on freenode is great and super helpful</li>
</ul>
<h2 id="in-summary">In summary</h2>
<p>"It's your foot". But I'll keep with learning the language, for I know a ton 
of people who can't imagine writing maintainable programs without static type
checking, yet I know it's possible. Back in the days of <a href="http://thatextramile.be/blog/2010/01/as-a-movement-alt-net-has-been-dead-for-a-while">Alt.NET</a>,
the motto was that we are adults, so we can use knives and scissors...</p>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2014/01/31/why-i-chose-elixir-to-learn-this-year-and-initial-impressions/">Why I chose Elixir to learn this year (and initial impressions)</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>When in Rome, do as the Romans do</title>
      <link>http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</link>
      <pubDate>Fri, 03 Dec 2010 08:30:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[programming languages]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</guid>
      <description>When in Rome, do as the Romans do</description>
      <content:encoded><![CDATA[
          
<div><div><a href="http://www.pragprog.com/the-pragmatic-programmer">The Pragmatic Programmer</a> gives a very popular advice: <a href="http://stackoverflow.com/questions/1003940/learn-a-new-language-every-year">learn a new language every year</a>. The main reason behind this advice is that when you learn a new language, you learn a new way to think. </div><div><br/></div><div>However, especially when getting started with a new one, we (inadvertently) try to understand it by comparing it to something we already know, which is likely the language we are most comfortable with, thus turning the learning experience into a square peg-round hole problem. Be aware of of this limitation before dismissing a language or a language feature as something horrible.</div><div><br/></div><div>Some easy to spot examples of mistakes I have seen myself and/or others make are:</div><div><ul><li>creating lots of simple DTO classes in Python instead of using tuples </li><li>trying to create a synchronous API for a web service call in Flex</li><li>creating an indexer for the immutable list in Scala</li><li>...</li><li>...and of course, procedural PL/SQL code with lot's of loops and ifs instead of set based operations</li></ul></div><div>The subtle differences (idioms) can be trickier, but are worthy to learn about. Similar operations can behave surprisingly differently in different languages. When splitting a collection in C#, asking for an invalid slice range, you get an IndexOutOfRangeException, while in a functional language you likely get an empty list as the result.  In Python it's  called <i>monkey patching</i>, while ruby people call that <i>opening up a class</i>. </div><div><br/></div><div>Even a seasoned programmer picking up a new language misses these  - so if you can get someone to review your code in such detail as it's been done for <a href="http://bestinclass.dk/index.clj/2010/10/taking-uncle-bob-to-school.html">Uncle Bob in Clojure</a> or <a href="http://davybrion.com/blog/2010/08/using-more-rubyesq-events-in-ruby/">Davy Brion in Ruby</a>, do yourself a favor, and ask for it!</div><div><br/></div><div>If you are afraid of learning in public, and don't have access to experienced mentors, <a href="http://www.hanselman.com/blog/TheWeeklySourceCode1.aspx">read code</a>, and try to understand unreadable-at-first bits - I have fond memories of the time we have tried figuring out what (and why) some method did in <a href="http://code.google.com/p/scalacheck/">scalacheck</a>.</div><div><br/></div><div>Note that I'm not saying you should not <a href="http://thisdeveloperslife.com/post/1620026288/1-0-8-motivation">innovate</a>, there have been (and will be!) great things coming out of concepts moving between platforms - boy I'm glad for NHibernate, and annotation based test methods coming from NUnit to JUnit were quite welcome too. However, first understand the platform's own means to the given end before deciding you need something from another platform. </div><div><br/></div><div>So <a href="http://phpadvent.org/2008/php-is-not-java-by-luke-welling">embrace the culture of the language</a>, and if you feel you are not learning something new in the new language, don't rest, but seek out those differences that surely are there under the hood! </div><div><br/></div><div>Happy learning, dear reader!</div></div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html">When in Rome, do as the Romans do</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
