<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Fri, 31 Jan 2014 10:49:56 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Why I chose Elixir to learn this year (and initial impressions)</title>
      <link>http://blog.zsoldosp.eu/2014/01/31/why-i-chose-elixir-to-learn-this-year-and-initial-impressions/</link>
      <pubDate>Fri, 31 Jan 2014 11:46:00 CET</pubDate>
      <category><![CDATA[elixir]]></category>
      <category><![CDATA[programming languages]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">_J8kM8aoHGnkBPYQ285TytaSHOE=</guid>
      <description>Why I chose Elixir to learn this year (and initial impressions)</description>
      <content:encoded><![CDATA[
          <p>Because I liked the color. Just kidding - but I didn't invest too much
time into making the choice - though I'm sure that all the things I read
or heard during this past year influenced me.</p>
<p>It quickly boiled down to <a href="http://golang.org/">Go</a> or <a href="http://www.elixir-lang.org/">Elixir</a></p>
<p>Elixir won because:</p>
<ul>
<li><a href="https://youtu.be/hht9s6nAAx8">Prag Dave recommends it</a></li>
<li>I wanted to finally follow through on a functional language (
  I've played with <a href="http://www.scala-lang.org/">Scala</a> and <a href="http://fsharp.org/">F#</a> before, but
  somehow I didn't fall in love)</li>
<li>For one reason or another I never got excited about <a href="https://www.ruby-lang.org/en/">Ruby</a>, 
  but people keep telling me how nice its syntax is, and Elixir's
  is inspired by Ruby's, so I should get a taste. And semicolons are
  not required!</li>
<li>it's running on the Erlang VM, which seems to be quite different
  from the things I've used in the past</li>
</ul>
<h2 id="first-impressions">First impressions</h2>
<p>So far, I haven't yet finished the second page of the <a href="http://elixir-lang.org/getting_started/1.html">tutorial</a>,
have solved the first few <a href="https://projecteuler.net">Euler problems</a>, subscribed to the 
<a href="http://groups.google.com/group/elixir-lang-talk">elixir-talk</a> mailing list, and have asked for help on the IRC
channel. So I'm quite at the beginning.</p>
<p>Some of the things that were a "culture shock" or at least 
unexpected/confusing for me were:</p>
<ul>
<li>To quit the REPL (<code>iex</code>), one has to do <code>CTRL-C</code>. Not <code>CTRL-D</code>, 
   or type exit. Since at first I didn't read the startup message,
   I had the "get me out of here" desperation first time <a href="http://www.vim.org/">Vim</a>
   users are famous for.</li>
<li>Different types require different pattern matching - 
  <code>{head | tail } = {1, 2, 3}</code> does not work, it only works on lists
  <code>[head | tail ] = [1, 2, 3]</code>.</li>
<li>Operators that should be the same are not. For concatenating strings,
   you use <code>&lt;&gt;</code>, but for joining two lists, you use <code>++</code>. My python
   roots rebel - even if this likely provides helpful type
   hints once I'm familiar with it</li>
<li>Strong (<code>and</code>, <code>or</code>, and <code>not</code>) and weak (<code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>)
   boolean comparisons. I'm quite afraid of the mistakes I'll go,
   not realizing whether I check for strict boolean values or just 
   against <code>nil/false</code>. Scary...</li>
<li>Unlike in Python, the REPL (<code>iex</code>) and the script executor (<code>elixir</code>)
   are two separate commands.</li>
<li>There are no semicolons alright, but there are too many <code>end</code>s required
   for my taste. Python did spoil me in this aspect...</li>
<li>Blocks need to be parenthesized properly otherwise some nasty surprises
   happen, e.g.: <code>is_number if true do 1 + 2 end</code> is parsed as
   <code>is_number(if true) do 1 + 2 end</code></li>
<li>Pattern matching is powerful on one hand, but quite limited in others.
   Probably once I understand how it works, I won't try to do things like<br>
   <code>a = 1</code><br>
   <code>(^a + 1) = 2</code><br> as match. Though I'm still curious why
   <code>^a = (2 - 1)</code> works</li>
<li>Guard clauses - probably the list of what you can and cannot do is due
   to some Erlang VM internals, but I dislike memorizing things...</li>
<li>Maybe it's too early for me to read <a href="https://github.com/elixir-lang/elixir/blob/master/CHANGELOG.md#v0123-dev">release notes</a> - reading
   "The list <code>[1, 2, three: :four]</code> now correctly expands to 
   <code>[1, 2, {:three, :four}]</code>" makes me feel again that I have to be super
   careful when reading code...</li>
</ul>
<p>But there are really nice and fun moments, such as:</p>
<ul>
<li>The installation was easy - thanks to <a href="http://devblog.avdi.org/2013/07/05/installing-elixir-on-ubuntu-13-04/">Avdi Grim's post</a>.</li>
<li>I was able to quickly understand the structure of the exceptions -
   the &lt;function name&gt;/&lt;N&gt; refers to the number of arguments
   of the function.</li>
<li>Nice utf support - though since all strings are bytes, I have to keep
   this in mind for pattern matching - <code>&lt;&lt;f, rest :: binary&gt;&gt;</code> matches
   differently from <code>&lt;&lt;f :: utf8, rest :: binary &gt;&gt;</code>. So maybe this belongs
   to the above list :)</li>
<li>I love how anonymous functions can be turned into full blocks, unlike in
   Python.</li>
<li><code>fib = Stream.unfold({0, 1}, fn {a, b} -&gt; {a, {b, a + b}} end)</code></li>
<li><code>#elixirlang</code> on freenode is great and super helpful</li>
</ul>
<h2 id="in-summary">In summary</h2>
<p>"It's your foot". But I'll keep with learning the language, for I know a ton 
of people who can't imagine writing maintainable programs without static type
checking, yet I know it's possible. Back in the days of <a href="http://thatextramile.be/blog/2010/01/as-a-movement-alt-net-has-been-dead-for-a-while">Alt.NET</a>,
the motto was that we are adults, so we can use knives and scissors...</p>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2014/01/31/why-i-chose-elixir-to-learn-this-year-and-initial-impressions/">Why I chose Elixir to learn this year (and initial impressions)</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>When in Rome, do as the Romans do</title>
      <link>http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</link>
      <pubDate>Fri, 03 Dec 2010 08:30:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[programming languages]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</guid>
      <description>When in Rome, do as the Romans do</description>
      <content:encoded><![CDATA[
          
<div><div><a href="http://www.pragprog.com/the-pragmatic-programmer">The Pragmatic Programmer</a> gives a very popular advice: <a href="http://stackoverflow.com/questions/1003940/learn-a-new-language-every-year">learn a new language every year</a>. The main reason behind this advice is that when you learn a new language, you learn a new way to think. </div><div><br/></div><div>However, especially when getting started with a new one, we (inadvertently) try to understand it by comparing it to something we already know, which is likely the language we are most comfortable with, thus turning the learning experience into a square peg-round hole problem. Be aware of of this limitation before dismissing a language or a language feature as something horrible.</div><div><br/></div><div>Some easy to spot examples of mistakes I have seen myself and/or others make are:</div><div><ul><li>creating lots of simple DTO classes in Python instead of using tuples </li><li>trying to create a synchronous API for a web service call in Flex</li><li>creating an indexer for the immutable list in Scala</li><li>...</li><li>...and of course, procedural PL/SQL code with lot's of loops and ifs instead of set based operations</li></ul></div><div>The subtle differences (idioms) can be trickier, but are worthy to learn about. Similar operations can behave surprisingly differently in different languages. When splitting a collection in C#, asking for an invalid slice range, you get an IndexOutOfRangeException, while in a functional language you likely get an empty list as the result.  In Python it's  called <i>monkey patching</i>, while ruby people call that <i>opening up a class</i>. </div><div><br/></div><div>Even a seasoned programmer picking up a new language misses these  - so if you can get someone to review your code in such detail as it's been done for <a href="http://bestinclass.dk/index.clj/2010/10/taking-uncle-bob-to-school.html">Uncle Bob in Clojure</a> or <a href="http://davybrion.com/blog/2010/08/using-more-rubyesq-events-in-ruby/">Davy Brion in Ruby</a>, do yourself a favor, and ask for it!</div><div><br/></div><div>If you are afraid of learning in public, and don't have access to experienced mentors, <a href="http://www.hanselman.com/blog/TheWeeklySourceCode1.aspx">read code</a>, and try to understand unreadable-at-first bits - I have fond memories of the time we have tried figuring out what (and why) some method did in <a href="http://code.google.com/p/scalacheck/">scalacheck</a>.</div><div><br/></div><div>Note that I'm not saying you should not <a href="http://thisdeveloperslife.com/post/1620026288/1-0-8-motivation">innovate</a>, there have been (and will be!) great things coming out of concepts moving between platforms - boy I'm glad for NHibernate, and annotation based test methods coming from NUnit to JUnit were quite welcome too. However, first understand the platform's own means to the given end before deciding you need something from another platform. </div><div><br/></div><div>So <a href="http://phpadvent.org/2008/php-is-not-java-by-luke-welling">embrace the culture of the language</a>, and if you feel you are not learning something new in the new language, don't rest, but seek out those differences that surely are there under the hood! </div><div><br/></div><div>Happy learning, dear reader!</div></div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html">When in Rome, do as the Romans do</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
