<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Sat, 05 Dec 2015 12:42:20 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>There Is More To Clean Code Than Clean Code</title>
      <link>http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</link>
      <pubDate>Fri, 03 Feb 2012 20:29:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</guid>
      <description>There Is More To Clean Code Than Clean Code</description>
      <content:encoded><![CDATA[
          
<p><a href="http://blog.8thlight.com/uncle-bob/2012/01/20/Fecophiles.html">A post written by Uncle Bob</a> in January (I'm behind my reading list) offended me. I absolutely agree with Uncle Bob's analysis regarding the code itself, and I also prefer the refactored version, but I have a problem with insulting the programmer(s) reluctant to appreciate the change. </p><br/><p>We write code in programming <em>languages</em>, and there are different levels of proficiency in a language.</p><br/><p>As I'm currently learning a new spoken language, I'm painfully aware of this - initially I probably sounded like a caveman. The first impression you get about me is totally different depending on the language I speak - but I am the same person!</p><br/><p>The learning curve of a language is not smooth - the steepness between consecutive <a href="http://en.wikipedia.org/wiki/Common_European_Framework_of_Reference_for_Languages#Common_reference_levels">levels of proficiency</a> is different. Going from not speaking any German to speaking A1 (tourist) level was easy, getting the basic grammar required for the low intermediate (B1) level wasn't too bad, but to get my German to the level where my English is will take more effort than the sum of all my previous investments<sup>1</sup>.</p><br/><p>Since it is my third foreign language I'm learning, I have no difficulty accepting that the level I think I speak is higher than the level I actually speak. Because of that, whenever someone rephrases my sentences in proper German <sup>2</sup>, I start from the assumption that likely their version is better, even if I don't understand first why - and I take the effort to understand their reasoning <sup>3</sup>. I do that despite that I was of course convinced that when I spoke, I expressed my thoughts in the best possible way.</p><br/><p>However, I don't have much at stake - no ego to hurt, no reputation to loose, and the roles are clear: I'm the beginner, and the people around me are the more experienced ones. In a software team, the roles might not be so clear - I had told colleagues almost twice my age how they should write code after only a few weeks of working there. Bad idea. Since then, I have learned <em>not</em> to start improving the coding style of a team by rewriting the code they have written, and showing off how much better my version is. Rather, I wait until a situation arises when they don't mind having me demonstrate some code improvements. I demo it, and explain why I do it that way. In my experience, the second approach is more effective, though it doesn't have that instant satisfaction and relief the first provides.</p><br/><p>As the joke goes, you need only one psychologist to change a light bulb, but the light bulb has to want the change real bad. </p><br/><p><a href="http://pragprog.com/book/trevan/driving-technical-change">Driving Technical Change</a> is hard, because it requires a mental/cultural change, and that change has to come from the inside - but can be catalyzed from the outside of course<sup>4</sup>. But just forcing practices or ways of working on unwilling recipients generates resistance (e.g.: <a href="http://www.npr.org/blogs/money/2011/12/16/143846133/the-friday-podcast-how-office-politics-could-take-down-europe">the story of the EU technocrat appointed to recalculate the 2009 Greek budget</a>).</p><br/><p>I would like to see more <a href="http://ayende.com/blog/tags/reviews">public code reviews</a> and public refactorings (e.g.: <a href="http://softwarelifecycle.wordpress.com/2012/01/08/an-exercise-in-refactoring/">Andrew Parker</a>, <a href="http://anarchycreek.com/doubledawgdare-series/">GeePawHill</a>), but I would like to see <a href="http://ayende.com/blog/153697/a-meta-post-about-negative-code-reviews">less public judgement passing on people</a> at the lower proficiency levels of programming. </p><br/><hr/><br/><p><sup>1</sup> there is a great <a href="http://hanselminutes.com/301/learning-to-speak-another-language-with-zach-owens">Hanselminutes episode on learning a foreign language</a> if interested. Beware, it may contain programming!</p><br/><p><sup>2</sup> German readers might disagree, since most Germans I meet speak Frankish :)</p><br/><p><sup>3</sup> Which of course, is sometimes harder for natives to properly explain than for novices to ask questions pointing out the seeming irregularities of the grammar</p><br/><p><sup>4</sup> And we won't always be able to foster change in all environments (note: this does not mean the others are at fault for not changing!). The same programmer can be highly productive in one team, and be the one slowing down another team. There is nothing wrong with changing jobs after realizing we are a net loss to a given team.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/06 11:53:39</em>: "I had told colleagues almost twice my age how they should write code after only a few weeks of working there."<br/><br/>Once I did the same: I pointed out that although they wanted to write a super-fast app, writing 500-line long methods just won't work. I also pointed out that having the code polluted with //System.out.println() -s is bad, that they should use some sort of logger instead.<br/><br/>It was pretty obvious to me, even before I read the the Clean Code book. Still, I believe this is why I couldn't get along with the team, and this is why was fired in 2.5 months.<br/><br/>The other side of the coin is: sometimes you just don't want to wait until the bulb wants the change really bad.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/06 20:55:06</em>: Hi bridge,<br/><br/>so I'm not the only one who made that mistake :). And you are right - when there is a culture clash in a team, or we need something other than what's possible (e.g.: we mostly would like to learn from others to improve our tech skills, and not work on our soft skills to be able to teach them our - potentially limited - understanding), moving on to another places probably the best thing - even if on occassion it's a move forced on us!
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/07 10:28:50</em>: Sure, there must be a lot of us who made that mistake :)<br/>On the other hand, I was asked to review their code. But, as it turns out, programmers are almost as sensitive about their code as poets are about their poems.
<ol>
<li id="2-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:18:58</em>: Giving feedback is tricky territory and requires either a built up trust or a lot of discipline from the feedback giver - even if one knows on the analytically that it's about the code, and not about the merits of the coder, a misdirected WTF (e.g.: *Who* wrote this mess?! vs. Look at *what* a mess *this* is.) can push the recipient into the defensive, preventing any positive discussion about *the code*.<br/><br/>Even if we can at least laugh at it (and ourselves), it still hurts - Kyle Baley gives a wonderful description of the feeling at http://codebetter.com/kylebaley/2012/01/30/qa-a-hillbilly-love-story/ :)
</li></ol></li><li id="3">
    <strong><a href="None">r1tch</strong></a> on <em>2012/02/07 14:19:04</em>: I dare to agree with Uncle Bob. :) If someone is as junior to have problems understanding the refactored code, then he should know to shut up. In the story, the two colleagues claimed the original was to be easier to understand! This is obvious bullsh*t. The only thing I might (might!) allow for their help is to add comments in the isPzt() function, explaining what's happening, like:<br/>// an item is PzT if:<br/>// it's non-null, AND<br/>// has parent, AND parent is nfo or discontinued<br/><br/>However, a company is in serious trouble is such comments are needed. Or am I just too spoilt here...? :)
<ol>
<li id="3-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:36:10</em>: Hi r1tch, <br/><br/>Thanks for your input and I appreciate that you did not phrased it as "I disagree with you" :) I don't think I should speculate about your degree of spoiltness (is there such a word?) :)<br/><br/>I *strongly* disagree with the statement &gt;&gt;If someone is as junior to have problems understanding the refactored code, then he should know to shut up&lt;&lt; though. First, I don't think years of experience is any indicator of skill level in itself. Second, effective teams are the ones when there are no (at least technical) unasked questions, and noone has to "just accept" the right way (see also: Cargo Cult). <br/><br/>With regards to easier to understand code - it might be easier for you or for me to understand, but when you've lived with a codebase, you have developed a certain familiarity with it, just like you can almost blindly walk to the newspaper stand on the corner. However, if someone was to alter the pathways, move some billboards around, even if it might be better use of the space, you would first be uncomfortable with it. OK, it's not a perfect analogy, but I hope it conveys my meaning.<br/><br/>We are also missing a lot of context here - e.g.: I likely wouldn't ask my colleagues after a refactoring to see whether it was correct or not, since the tests would catch if I made a mistake. But if there are no test cases, and this code is in a central part of the codebase, I can understand why team members would be worry of the new, untested, unfamiliar code. Also, while I'm not sure how it is on that team, but if someone would respond to me in a way that is described as "willing to put up with my change to shut me up", I would ask myself whether I might be doing something wrong.<br/><br/>And I wouldn't put the kind of description you put into the comments, but rather into testcases :)
</li></ol></li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html">There Is More To Clean Code Than Clean Code</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>On Grassroots/Peer TDD Introduction</title>
      <link>http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html</link>
      <pubDate>Sun, 15 May 2011 14:43:00 CEST</pubDate>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[tdd]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html</guid>
      <description>On Grassroots/Peer TDD Introduction</description>
      <content:encoded><![CDATA[
          
<p>While I'm no trainer/coach, I've been involved in spreading TDD among my peers, with varying extent of success. Recently someone asked for advice on how they should go about it, and in the spirit of <a href="http://sethgodin.typepad.com">Seth Godin</a>, instead of responding in a private email, I wrote this post, a mix of experience and hindsight ideas.</p><br/> <p>So, we are one (or two) developers in the team/company, already sold on TDD, with some unit testing experience. The peers are willing to listen to the concept, and  management, while not willing to invest in formal training, is ok giving a chance, as long as it doesn't hurt the projects' performance. How do we go about it?</p><br/> <h2>Don't introduce TDD on the project</h2><br/> <p>It's common that teams learn/practice new skills on live projects after a basic overview/training. While this might work, I would not recommend this approach for any grassroots initiative, because the chances of failure are significant, and one bad experience with a practice/technology can doom any further attempts to introduce it later, even if not the practice was at fault, only was applied without enough practice. A project manager friend of mine recently complained to me that since the team that worked on a massive legacy project started doing TDD, tasks that used to take hours begun to take days, and clearly, he wasn't happy about that. It turned out that the problem wasn't due to TDD, but lack of discipline (developers went overboard with refactoring, touching parts of the codebase not even remotely connected to the task they've been working on). Despite this, he could have easily come to the conclusion that TDD equals to dropped productivity, without much benefit (bug reports kept coming in, even if for different features - we are talking about legacy code!). Any new skill has a learning curve, you will be slowed down, and you won't get it perfect the first time - don't give a chance for the others to associate failures with the new concept. If you are like me and would need a more concrete example about refactoring just enough, I suggest you read <a href="http://xprogramming.com/">Ron Jeffries</a>' <a href="http://www.amazon.com/Extreme-Programming-Adventures-DV-Microsoft-Professional/dp/0735619492">Extreme Programming Adventures in C#</a> book, and on advice for dealing with legacy code, the undisputed classic book is <a href="http://michaelfeathers.typepad.com/">Michael Feathers</a>' <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a>.</p><br/> <h2>Introducing/selling TDD to the other developers</h2><br/> <p>A lot of technical presentations focus on the <strong>how</strong> instead of <strong>why</strong> it is beneficial to the audience. When it comes to TDD, I would also suggest presenting it simple - skip the emerging design concept (some of the early advocates noted that good design emerging from TDD might had to do with the fact that those early advocates actually had great design sense anyway), don't mention YAGNI - in short, don't overload them with new concepts. I rather liked the approach <a href="http://www.paulbutcher.com/">Paul Butcher</a> took in his <a href="http://pragprog.com/titles/pbdp/debug-it">Debug It!</a> book - we tend to program one baby step at a time, articulating in our mind what the next behavior we'll implement should be, then we code it, and move to the next behavior. TDD (or Test First Development for the nitpickers :)) is just a minor step from that, i.e.: we actually write down the articulated concept in code (which we tend to do anyways with the throwaway main methods used for debugging). And in addition, we get an automated regression test suite for free :). While a live demo could be cool, I would probably show <a href="http://katas.softwarecraftsmanship.org/?p=71">one</a> of the <a href="http://www.katacasts.com/">Kata casts</a> instead of me typing on the projector. Also, be sure to point out that at first we won't be able to code at this speed (I still can't)!</p><br/> <h2>Learning/practice</h2><br/> <p>TDD is a rather simple concept, but so are all the great wisdoms - it takes a lot of time and experience to fully understand those concepts. After the initial TDD sales pitch, I would dedicate a session to going over the tools and the basic usage - how to install the test library, how to run the tests, how to debug a single test, and the basic assert statements - <a href="http://www.nunit.org/index.php?p=equalityAsserts&amp;r=2.5.10">AreEqual</a> vs. <a href="http://www.nunit.org/index.php?p=identityAsserts&amp;r=2.5.10">AreSame</a>, <a href="http://www.nunit.org/index.php?p=exceptionAsserts&amp;r=2.5.10">Assert.Throws</a>, and also an example to show that most likely there are more asserts in the library (e.g. <a href="http://www.nunit.org/index.php?p=stringAssert&amp;r=2.5.10">StringAssert.EndsWith</a>).</p><br/> <p>With those interested/committed, we can move on to the <strong>supervised practice</strong> step. We've worked on <a href="http://codingdojo.org/cgi-bin/wiki.pl?KataCatalogue">simple problems</a>, in a structure inspired by this <a href="http://www.infoq.com/presentations/Building-Good-Habits">Peer learning presentation</a> by <a href="http://www.codemanship.co.uk/">Jason Gorman</a> (his site even has a full <a href="http://www.codemanship.co.uk/sc_at_bbc.pdf">case study</a> of this applied at the BBC). The <a href="http://codingdojo.org/cgi-bin/wiki.pl?WhatIsCodingDojo">coding dojo</a> is another possible format. Important thing is discuss the experiences, lessons learnt, and problems overcome with the whole group, because while practice makes one perfect, bad, practiced habits are hard to unlearn. It is OK not to have all the answers - just be ready to admit it, and ensure that you can find it out from somewhere. Meetups, user groups, and similar forums are invaluably helpful.</p> <br/> <p>Be sure to eat elephant in a piecemeal fashion - while at first the simple problems seem contrived, don't attempt to practice testing existing, complex production code. Stick to the simple problems for practice, every now and then actually demonstrate that it is possibly to test legacy code (though it'll require quite some preparation from you), maybe have some of these examples as a group exercise, but be sure to keep the practice focused on the simple mechanics initially. Just like any sport practice - you repeat rather basic exercises over and over, because it does pay off in the long run, but to keep you motivated, you do have the free practice sessions too.</p><br/> <h2>Don't force it</h2><br/> <p>Not everyone has the same passion as you do (you must have if you read this far :)), and some take a longer time to learn, have different pre-existing concerns they should overcome. Lead by example, be available to talk about it, answer questions, clarify, but don't try to force it on them. Urban cycling didn't became popular because we, cyclists, were preaching to pedestrians and car drivers - we were just approachable to friends, coworkers, etc. and provided answers and listened to their concerns. Yes, it could take a long time, but patience pays off - self-motivated people are more likely to overcome the hurdles they inevitably will face in the learning process!</p><br/> <h2>Bringing it to production</h2><br/> <p>I wouldn't set strong rules or hard deadlines like "two months from now, you all must write all production code in a TDD fashion", but rather just tell people to feel free to experiment during their daily work, but ensure they don't confuse work and practice. If they get stuck on testing some problem, they should just make a note, and deliver the feature untested, as they used to do before. Later, together with the group they should discuss it and potentially find a way to test it.</p><br/> <h2>Further resources</h2><br/> <p>This post is just a high level overview, and I have simply glossed over many of the actual difficulties about writing good unit tests, keeping them maintainable, etc.. There are books written about the topic, in almost all programming languages. Coming from a .NET background, I can recommend <a href="http://www.amazon.com/Art-Unit-Testing-Examples-NET/dp/1933988274/">The Art of Unit Testing with examples in .NET</a> by <a href="http://osherove.com/">Roy Osherov</a>, and I've found <a href="http://jamesshore.com/">James Shore</a>'s <a href="http://jamesshore.com/Blog/Lets-Play/">Let's Play TDD</a> Java episodes great - the best thing about the latter is the thought process narrative that goes with it. <a href="http://pragprog.com/titles/trevan/driving-technical-change">Driving Technical Change</a> might be another good book, though I haven't yet read that.</p><br/> <p>Good luck!</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/18146700402920753476">Miklos</strong></a> on <em>2011/05/16 19:10:12</em>: Thank you for your valuable advice PÃ©ter, it will be very useful for our TDD study group. I especially like that you answered in a blog post instead of an email, so other people can also benefit from your answer.
</li><li id="2">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2011/05/16 19:55:11</em>: @Miklos: my pleasure :) Would  be fun to read about your experience (and lessons learned) in a couple of months!
</li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html">On Grassroots/Peer TDD Introduction</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>How & Why I do code reviews</title>
      <link>http://blog.zsoldosp.eu/2011/03/how-why-i-do-code-reviews.html</link>
      <pubDate>Thu, 17 Mar 2011 11:00:00 CET</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[practice]]></category>
      <category><![CDATA[code]]></category>
      <category><![CDATA[quality]]></category>
      <category><![CDATA[team]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2011/03/how-why-i-do-code-reviews.html</guid>
      <description>How & Why I do code reviews</description>
      <content:encoded><![CDATA[
          
<p><a href="http://en.wikipedia.org/wiki/Code_review">Code review</a> is one of the programming practices that I advocate. However, as with any practice, I find understanding and communicating the values and driving forces behind it even more important than the actual practice itself (see: <a href="http://en.wikipedia.org/wiki/Cargo_cult">Cargo Cult</a>). So, here is my take on code reviews.</p> <h2>Why?</h2> <p>I'm pretty much against introducing any practice just for the sake of introducing it. Different goals require different means, and without clear goals, it's rather difficult to evaluate whether a practice has helped the team or not. The reason I practice code reviews are:</p> <p><strong>Knowledge sharing</strong> (note: none of the teams I've been part of practiced <a href="http://jamesshore.com/Agile-Book/pair_programming.html">pair programming</a>, which serves this purpose quite well). It's a way to break the silos that exist within the team, regardless if they are horizontal (UI, server side, data access, etc.) or vertical (<em>this is Jane Doe's component, noone else can touch that for there dragons live</em>). I rather like that when I ask for a holiday my manager doesn't have to consider whether or not there is anyone who could work with my (recent) code.</p> <p><strong>Mentoring</strong>, though could be considered part of knowledge sharing, deserves to stand out on its own. I've found a lot of the concepts I came across first way too abstract, when read in a book, but when explained in context <em>(what you've just written there is known as the Factory pattern...</em>) I get a better and deeper understanding of it.</p> <p><strong>Culture creation</strong>. Again, abstract vs. concrete, talking vs. doing. One can have so many coding guidelines, best practices, etc. documents written. However, these documents usually highlight high level objectives, and almost any concrete implementation can be argued to fit with the description. I much prefer people arguing whether or not a new class should be extracted or not to a dry design guideline setting limits on the number of methods of a class and just checking against that formally (if at all).</p> <p><strong>Quality Assurance</strong>. Are there enough and appropriate tests? Do they makes sense to the next person (I routinely had to rename tests for my reviewers, because I was already too close to the code and didn't communicate intent well enough)? Are actually all tests passing? Haven't you accidentally reinvented the wheel (I've once failed to recognize that what I'm working with is an existing domain concept - the beauty of working with legacy code - so I created another model class for it)?</p> <p>Last, but not least, <strong>catching obvious bugs</strong> is a benefit not to be overlooked. Face it: we all make mistakes, that are embarassing in hindsight. Catching them during the development cycle is keeps the embarassment in a smaller circle :)<br/> </p><h2>What?</h2> <p>Computers have been invented to automate tiresome, repetitive, and boring tasks. Spending programmer time on checking tabs vs. spaces, curly brace placement, and other such, easily automated checks (<a href="http://stylecop.codeplex.com/">StyleCop</a>, <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>, <a href="http://findbugs.sourceforge.net/">FindBugs</a>, etc.) is more than waste. If such things are important for you, do a quick check that there are no warnings in the build for these, and move on to the areas where value is added.</p> <h2>When?</h2> <p>Code reviews should be concerned with small, easily digestible chunks, just like commits. That's why I prefer to review commits. <strong>Before they are commited</strong>. I can only offer nonscientific justification (experience + anecdotal), and no explanation, but my observation is that committing code makes it just as rigid as clay becomes in the oven - it becomes much more difficult to change it. Renaming a method/variable is much easier while it's still in the staging area (maybe the burden of writing another commit message?). This also gives enough time to ensure that tests are run before each commit (run the command line build while the review is ongoing).<br/> </p><p>Some suggest that developers should ask for code review when they feel it's a riskier change they've made. Since I'm really bad at predicting when I make mistakes (to be frank, I tend not to be able to predict), just to be on the safe side (and to ensure the flow of information), I advocate to review <strong>every commit</strong>.</p> <h2>How?</h2> <p>There are multiple ways to achieve the same thing, one that I've found working is the following:</p><ol> <li>the developer who just completed a commitable chunk of work, signals the others (via a team chat window, though <a href="http://cm.baylor.edu/welcome.icpc">ACM ICPC</a> style balloons could work too) that she can be reviewed.<ol type="a"> <li>someone from the team picks up the request in the next few minutes - this delay ensures that the reviewer is not interrupted and dragged out from the flow.</li> <li>If noone picks it up in a few minutes, the developer stashes his work, and continues working until someone becomes available, when they return to the <em>original</em> change set.</li></ol></li> <li>the command line build is started on the developer's machine while the nature of changes is described in a few sentences to the reviewer, so the context is set</li> <li>the reviewer drives the order the changes are reviewed. She asks questions, requests clarifications, which usually result in <a href="http://www.refactoring.com/catalog/renameMethod.html">rename refactorings</a>.<br/>I tend to start reviewing the tests - first reviewing the names make sense and no relevant corner cases are missed, then the actual test code. Only once I'm happy with that do I turn to the actual code.<ol type="a"> <li>if any major flaws (bug, failing test, duplication - anything that cannot be fixed as fast as discussing it) are discovered, the code cannot be commited, and another review is needed (we tend to have that next reviewer be the same person as the one before in order not to slow down the process).</li> <li>otherwise, the normal <a href="http://codebetter.com/jeremymiller/2005/07/25/using-continuous-integration-better-do-the-check-in-dance/">checkin dance</a> begins, and the code is committed.</li></ol></li></ol> <h2>Cons, worries, and pitfalls (real and unreal ones)</h2> <p>Just like any other practice, this <strong>takes time</strong> to learn and to do. However, I rather prefer the extra few minutes spent discovering duplication than the days it'd take later to remove. Exposing the potential misunderstandings that wouldn't be discovered while just talking again justifies it. If a review takes longer than a few minutes, that signals there is a deeper issue there, which should be discussed - like agile practices promote, we've exposed a problem early. In summary: I think <strong>it's worth it</strong>.</p> <p><strong>Co-location</strong>, while certainly makes the process easier, is <strong>not required</strong>. If you are working in a remote team, you probably have appropriate communication channels. A voice call with shared screen is all that's needed.</p> <p>It takes <strong>effort and discipline</strong>. If the reviewer doesn't pay enough attention, isn't engaged, it's not going to work. Discussing regularly what kind of problems slipped through the past code reviews and whether they could (should) have been caught could be part of <a href="http://en.wikipedia.org/wiki/Retrospective#Software_development">retrospectives</a>.</p> <p>Just as it's possible to create horrible designs with TDD, it's just as easy to deviate from the architecture, design of the program in small, correct steps. Even when reviewing only small chunks, <strong>keep in mind the big picture</strong>.</p><p>Some teams do post commit code reviews instead, arguing that <strong>if we do it in an asynchronous fashion, the work of others is not interrupted</strong>, the developer is not slowed down by waiting for others. While I've seen teams practice post commit reviews effectively (as they say, a team of good developers is likely to achieve good results regardless of the process/practices they follow), so I'm not saying that can't work, but I prefer to do it before. In addition to the clay analogy used above, <strong>synchronous communication is more effective than asynchronous</strong> (at least between humans, between machines its another story). At the end of the day, developers will still need to talk with each other for clarification, so not much time is saved anyway.</p> <p><strong>Tooling</strong>. Most code review software don't support pre commit reviews, however, they have value for other purposes. I like them to start discussions on things I see in the <strong>code that don't need immediate changes</strong> for the features we are working on now, but should be discussed at some point - either to become a nice to have task, or to actually realize it's a must have refactoring. I find these tools can be more effective than leaving TODO comments in the source code - threaded discussions are nice, and hard to have in code comments. Another area where they shine is <strong>architecture/prototype reviews</strong>. It's a great way to prepare for a design review meeting. And yes, I do prefer code based architecture evaluation to UML diagrams (though the later are useful when communicating about the architecture), because concrete coded scenarios can bring up more flaws than the white board - see the <a href="http://codebetter.com/jeremymiller/2007/01/21/the-anti-team/">Non Coding Architect</a>.<br/> </p><p>And do I need to say it? Just as any other practice, <strong>it's no silver bullet</strong>!</p> <hr/><p>With regards to silver bullets - nothing is perfect, including this approach and the post itself. Please, <strong>do leave a comment</strong> pointing out any improvements/problems!</p><br/><hr><br/><p><strong>Update</strong>: <a href="http://www.zsoltfabok.com/blog/2011/08/code-review-during-retro/">Code Review During Retrospective</a> lays out a great approach for purely educational focused code reviews, I recommend reading that too!</p></hr>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2011/03/how-why-i-do-code-reviews.html">How & Why I do code reviews</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Dealing with crunch mode</title>
      <link>http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html</link>
      <pubDate>Sun, 31 Oct 2010 21:10:00 CET</pubDate>
      <category><![CDATA[software]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[team]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html</guid>
      <description>Dealing with crunch mode</description>
      <content:encoded><![CDATA[
          
<div>Before going any further: I think that crunch mode is not sustainable and is best avoided. I won't analyze the phenomen or its causes, there has been <a href="http://www.infoq.com/news/2008/01/crunch-mode">much written about it</a>. However, given it definitely exists, though usually for shorter periods of time. Having had this experience a number of times, I felt I should organize my thoughts for future reference (for myself, and maybe for others too).</div><div><br/></div><div>Some of the points below might sound like good practice for software development in general - often we only start working on process problems after they've blown up into our face. <b><i>Holding <a href="http://en.wikipedia.org/wiki/Retrospective#Software_development">retrospectives</a></i></b> after such periods can bring quite a change, so don't miss out on the opportunity! However, we haven't even started yet, so let's step back in time.</div><div><br/></div><div><b><i>Knowing why</i></b> the close deadline is important from the beginning is crucial to keep the team motivated during this period. Working overtime for no apparent reason makes the already bad situation worse.</div><div><br/></div><div><b><i>Have well defined</i> </b>boundaries for both <b><i>time and scope</i></b>. This is generally a good practice, but this is a must - setting out on a death march without a clear purpose is unlikely to succeed. Break things down into small (4-8 hours) tasks, prioritize them (and I mean an ordered list, not making all of them into critical priority). If the added up estimates already run out of the possible available time,<b> <i>cut scope</i></b>. Most likely the only way it can be cut is vertical - e.g.: we will have logging, but we will work against only a single library, and won't make it pluggable for this deadline. Or we won't make the logging destination configurable (though it's a contrived example, it helps making the point).</div><div><div><br/></div><div><b><i>Taking on technical debt</i></b> can help. Be sure you all understand that this does not equal to crap code, unconditional copy-paste, etc..  Only introduce debt knowingly (you might want to keep an actual list of the shortcuts you have taken so you know what to fix in the upcoming releases).</div><div><br/></div><div><b><i>Stop experimenting</i></b> and move back to the comfort zone. Almost all projects involve some new element that the team is not familiar with it. If the team is just learning unit testing, they likely write the tests after they got the code to work, and are taking a long time to write them. In that situation, not writing tests for the time being could be the right choice. However, be careful to get the right message across - you are <b><i>not dropping the practice because it slows</i></b>development down, <b><i>but</i></b> only <b><i>rescheduling the learning period</i></b> to some other time. Also, just like with performance optimizations, make these decisions after measuring - <b><i>don't do it</i>based on speculation</b>.</div><div><br/></div><div>On the non-technical front, you can <b><i>cut back on meetings</i></b>, both in numbers and in duration. You might also want to schedule them so they don't interrupt the workflow. Have a status in the morning and at the end of the day, with a team lunch if more discussion is needed.</div><div><br/></div><div><b><i>Work from home</i></b>. Of course, some infrastructure is needed, and it might not be an option for everyone, especially for the person where next door is a construction site. However, saving on the commute time might could give you some extra time during the day without cutting too much into your personal life. Significant Others are more understanding if you are a bit more tired when they get to see you at least. </div></div><div><br/><hr/>[Scope section was updated based on <a href="http://twitter.com/#!/ljszalai/status/29308952267">@ljszalai's comment on twitter</a>]</div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/10/dealing-with-crunch-mode.html">Dealing with crunch mode</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
