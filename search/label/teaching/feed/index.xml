<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Tue, 19 Apr 2016 10:39:21 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>The Power of (Open Source) Blueprints</title>
      <link>http://blog.zsoldosp.eu/2015/12/05/the-power-of-open-source-blueprints/</link>
      <pubDate>Sat, 05 Dec 2015 13:41:00 CET</pubDate>
      <category><![CDATA[coderetreat]]></category>
      <category><![CDATA[community]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[organizing]]></category>
      <category><![CDATA[citcon]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">TmQscoJEA-SD6hw3sIe4T-DcJt4=</guid>
      <description>The Power of (Open Source) Blueprints</description>
      <content:encoded><![CDATA[
          <h2 id="what-are-blueprints">What are blueprints</h2>
<p>As per Wikipedia, a <a href="https://en.wikipedia.org/wiki/Blueprint">blueprint</a> is something that <em>allowed
rapid and accurate reproduction of documents</em>. I have heard it used (and
used myself) for processes too.</p>
<p>They are powerful because they allow me or anyone else to recreate
someone else's tried and tested idea, which in turn allows the idea
to spread (scale) to unimaginable numbers and reach places (and provide
benefits to) the original inventor could have never dreamed of.</p>
<p>It allows a complete novice to the field to organize a successful event.
Think of it like a <a href="https://en.wikipedia.org/wiki/Franchising">franchise</a>. You yourself do put in the
work, and your success benefits the franchise as well as yourself.
However, you don't have to start from scratch; you have a process you
follow, that has been proven to work. When advertising your event, there
is the social proof that the brand exists that makes it easier to sell
it.</p>
<h2 id="examples">Examples</h2>
<p>Some such blueprints I've come across and worked with are</p>
<ul>
<li>the <a href="http://citconf.com/">CITCON</a> meta wiki about <a href="http://citconf.com/wiki/index.php?title=ConferencePlanning">organizing the open space
  conference</a> - and <a href="http://citconf.com/archive/budapest2012//">CITCON Budapest</a> was
  quite a success, which I couldn't have pulled off without having
  the process to follow</li>
<li><a href="http://coderetreat.org/">Coderetreats</a> - I've participated and facilitated in
  public &amp; firm-internal events. The educational sessions and the superb
  detailed documentation the coderetreat community provides make it
  almost too easy to run such an event - no surprise that in 2015 there
  were <a href="http://coderetreat.org/events/event/listByType?type=gdcr15">at least 158 events</a> on a single day!</li>
<li><a href="https://djangogirls.org/">Django Girls</a> - it started in June 2014 in Berlin, and
  by now it already took place on all continents - simply because they 
  have a wonderfully detailed tutorial on how to organize such an event!</li>
<li>the <a href="http://alistair.cockburn.us/Elephant+carpaccio">Elephant Carpaccio</a> also has a super detailed
  <a href="https://docs.google.com/document/d/1TCuuu-8Mm14oxsOnlk8DqfZAA1cvtYu9WGv67Yj_sSk/pub">facilitation guide</a></li>
</ul>
<p>... but I'm sure there are many more out there.</p>
<h2 id="benefits">Benefits</h2>
<p>If you are trying to bring change in your company/team, but you haven't
done it before, you don't have to necessarily invent workshops yourself
(of course, if you want, you can), but can simply take off established
ones "from the shelf".</p>
<p><em>Caution</em>: while you could theoretically run an event just from the
tutorials, it might be beneficial to have attended such a workshop
before running it. I've cooked my first <a href="https://en.wikipedia.org/wiki/Paella"><em>paella</em></a> from a 
cookbook, without ever having eaten one before. While everyone agreed
I've cooked something delicious, later we had to acknowledge it had 
little to do with a real paella :)</p>
<h2 id="if-you-are-already-organizing-something">If you are already organizing something</h2>
<p>If you can afford it, I highly suggest you publicly document it (and
license it openly), so others have a chance to do the same. E.g.: many
user groups struggle finding speakers or sponsors - it would be great to
have a handbook on your sponsor/speaker attraction tactics. It won't
take away from the success of your event or the benefits to your
reputation, you simply just enable more people elsewhere to do the same!</p>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2015/12/05/the-power-of-open-source-blueprints/">The Power of (Open Source) Blueprints</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Teach me refactoring from my commits!</title>
      <link>http://blog.zsoldosp.eu/2013/09/27/teach-me-refactoring-from-my-commits/</link>
      <pubDate>Fri, 27 Sep 2013 09:40:00 CEST</pubDate>
      <category><![CDATA[things i wish existed]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[untested ideas]]></category>
      <category><![CDATA[version control]]></category>
      <category><![CDATA[refactoring]]></category>
      <guid isPermaLink="false">GZ4JOnYZvQe5D8VUfKUh6eJAlkw=</guid>
      <description>Teach me refactoring from my commits!</description>
      <content:encoded><![CDATA[
          <p>I find it hard to learn purely by abstract theory - I need practical 
examples to illustrate the theory I just learned. I also need practice,
and preferably, supervised practice, so my mistakes can be caught early
and/or more efficient ways can be shown to achieve the same thing I just
did.</p>
<p>With this background, it's not surprising that when I <a href="http://episodes.gitminutes.com/2013/06/gitminutes-14-pablo-santos-on.html">heard about a 
product that started to do semantic diffs for version 
control</a> I was reminded of the <a href="https://sc2010subs.wordpress.com/2010/08/13/refactoring-golf-dave-cleal-ivan-moore/">Refactoring 
Golf</a> concept from the first <a href="http://www.codemanship.co.uk/parlezuml/softwarecraftsmanship/">Software Craftsmanship 
London</a> conference - and the two ideas just clicked into this
great (ok, I'm biased) idea to try to derive the most efficient
refactoring steps for that particular commit I just made.</p>
<p>The pieces required for this project are all already in place:</p>
<ul>
<li>we have parsers for languages, and many are available as libraries to
  traverse <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">ASTs</a></li>
<li>most version control systems have libraries to read from them</li>
<li>there are tons of well-defined refactorings known, that can be used
  as operations in the transformations from state <code>A</code> to <code>B</code></li>
<li>optimization algorithms are plentiful - for a proof of concept, the
  <a href="https://en.wikipedia.org/wiki/String_distance">String Distance</a> Transformation algorithm could be used</li>
</ul>
<p>Thus such a program script could be added as a post commit hook, or 
simply could be run on the workspace copy, using the diff against last
committed version, and it could tell me that I might have:</p>
<ol>
<li>renamed variable <code>login</code> to <code>username</code></li>
<li>converted <code>username</code> from local variable to method parameter</li>
<li>extracted method <code>lock_customer_acocunt</code> from method <code>login</code></li>
</ol>
<p>I'm pretty positive even experienced refactoring practitioners could 
learn new tricks, and newbies would be delivered concrete refactoring
examples tailored to their very codebase.</p>
<p>Please, someone with enough free time, go and make such an app!</p>
<p>Does this idea make sense for you too, or just me? Let me know via email
(hello at site domain) or on twitter (<a href="https://twitter.com/zsepi">@zsepi</a>)!</p>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2013/09/27/teach-me-refactoring-from-my-commits/">Teach me refactoring from my commits!</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>There Is More To Clean Code Than Clean Code</title>
      <link>http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</link>
      <pubDate>Fri, 03 Feb 2012 20:29:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</guid>
      <description>There Is More To Clean Code Than Clean Code</description>
      <content:encoded><![CDATA[
          
<p><a href="http://blog.8thlight.com/uncle-bob/2012/01/20/Fecophiles.html">A post written by Uncle Bob</a> in January (I'm behind my reading list) offended me. I absolutely agree with Uncle Bob's analysis regarding the code itself, and I also prefer the refactored version, but I have a problem with insulting the programmer(s) reluctant to appreciate the change. </p><br/><p>We write code in programming <em>languages</em>, and there are different levels of proficiency in a language.</p><br/><p>As I'm currently learning a new spoken language, I'm painfully aware of this - initially I probably sounded like a caveman. The first impression you get about me is totally different depending on the language I speak - but I am the same person!</p><br/><p>The learning curve of a language is not smooth - the steepness between consecutive <a href="http://en.wikipedia.org/wiki/Common_European_Framework_of_Reference_for_Languages#Common_reference_levels">levels of proficiency</a> is different. Going from not speaking any German to speaking A1 (tourist) level was easy, getting the basic grammar required for the low intermediate (B1) level wasn't too bad, but to get my German to the level where my English is will take more effort than the sum of all my previous investments<sup>1</sup>.</p><br/><p>Since it is my third foreign language I'm learning, I have no difficulty accepting that the level I think I speak is higher than the level I actually speak. Because of that, whenever someone rephrases my sentences in proper German <sup>2</sup>, I start from the assumption that likely their version is better, even if I don't understand first why - and I take the effort to understand their reasoning <sup>3</sup>. I do that despite that I was of course convinced that when I spoke, I expressed my thoughts in the best possible way.</p><br/><p>However, I don't have much at stake - no ego to hurt, no reputation to loose, and the roles are clear: I'm the beginner, and the people around me are the more experienced ones. In a software team, the roles might not be so clear - I had told colleagues almost twice my age how they should write code after only a few weeks of working there. Bad idea. Since then, I have learned <em>not</em> to start improving the coding style of a team by rewriting the code they have written, and showing off how much better my version is. Rather, I wait until a situation arises when they don't mind having me demonstrate some code improvements. I demo it, and explain why I do it that way. In my experience, the second approach is more effective, though it doesn't have that instant satisfaction and relief the first provides.</p><br/><p>As the joke goes, you need only one psychologist to change a light bulb, but the light bulb has to want the change real bad. </p><br/><p><a href="http://pragprog.com/book/trevan/driving-technical-change">Driving Technical Change</a> is hard, because it requires a mental/cultural change, and that change has to come from the inside - but can be catalyzed from the outside of course<sup>4</sup>. But just forcing practices or ways of working on unwilling recipients generates resistance (e.g.: <a href="http://www.npr.org/blogs/money/2011/12/16/143846133/the-friday-podcast-how-office-politics-could-take-down-europe">the story of the EU technocrat appointed to recalculate the 2009 Greek budget</a>).</p><br/><p>I would like to see more <a href="http://ayende.com/blog/tags/reviews">public code reviews</a> and public refactorings (e.g.: <a href="http://softwarelifecycle.wordpress.com/2012/01/08/an-exercise-in-refactoring/">Andrew Parker</a>, <a href="http://anarchycreek.com/doubledawgdare-series/">GeePawHill</a>), but I would like to see <a href="http://ayende.com/blog/153697/a-meta-post-about-negative-code-reviews">less public judgement passing on people</a> at the lower proficiency levels of programming. </p><br/><hr/><br/><p><sup>1</sup> there is a great <a href="http://hanselminutes.com/301/learning-to-speak-another-language-with-zach-owens">Hanselminutes episode on learning a foreign language</a> if interested. Beware, it may contain programming!</p><br/><p><sup>2</sup> German readers might disagree, since most Germans I meet speak Frankish :)</p><br/><p><sup>3</sup> Which of course, is sometimes harder for natives to properly explain than for novices to ask questions pointing out the seeming irregularities of the grammar</p><br/><p><sup>4</sup> And we won't always be able to foster change in all environments (note: this does not mean the others are at fault for not changing!). The same programmer can be highly productive in one team, and be the one slowing down another team. There is nothing wrong with changing jobs after realizing we are a net loss to a given team.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/06 11:53:39</em>: "I had told colleagues almost twice my age how they should write code after only a few weeks of working there."<br/><br/>Once I did the same: I pointed out that although they wanted to write a super-fast app, writing 500-line long methods just won't work. I also pointed out that having the code polluted with //System.out.println() -s is bad, that they should use some sort of logger instead.<br/><br/>It was pretty obvious to me, even before I read the the Clean Code book. Still, I believe this is why I couldn't get along with the team, and this is why was fired in 2.5 months.<br/><br/>The other side of the coin is: sometimes you just don't want to wait until the bulb wants the change really bad.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/06 20:55:06</em>: Hi bridge,<br/><br/>so I'm not the only one who made that mistake :). And you are right - when there is a culture clash in a team, or we need something other than what's possible (e.g.: we mostly would like to learn from others to improve our tech skills, and not work on our soft skills to be able to teach them our - potentially limited - understanding), moving on to another places probably the best thing - even if on occassion it's a move forced on us!
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/07 10:28:50</em>: Sure, there must be a lot of us who made that mistake :)<br/>On the other hand, I was asked to review their code. But, as it turns out, programmers are almost as sensitive about their code as poets are about their poems.
<ol>
<li id="2-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:18:58</em>: Giving feedback is tricky territory and requires either a built up trust or a lot of discipline from the feedback giver - even if one knows on the analytically that it's about the code, and not about the merits of the coder, a misdirected WTF (e.g.: *Who* wrote this mess?! vs. Look at *what* a mess *this* is.) can push the recipient into the defensive, preventing any positive discussion about *the code*.<br/><br/>Even if we can at least laugh at it (and ourselves), it still hurts - Kyle Baley gives a wonderful description of the feeling at http://codebetter.com/kylebaley/2012/01/30/qa-a-hillbilly-love-story/ :)
</li></ol></li><li id="3">
    <strong><a href="None">r1tch</strong></a> on <em>2012/02/07 14:19:04</em>: I dare to agree with Uncle Bob. :) If someone is as junior to have problems understanding the refactored code, then he should know to shut up. In the story, the two colleagues claimed the original was to be easier to understand! This is obvious bullsh*t. The only thing I might (might!) allow for their help is to add comments in the isPzt() function, explaining what's happening, like:<br/>// an item is PzT if:<br/>// it's non-null, AND<br/>// has parent, AND parent is nfo or discontinued<br/><br/>However, a company is in serious trouble is such comments are needed. Or am I just too spoilt here...? :)
<ol>
<li id="3-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:36:10</em>: Hi r1tch, <br/><br/>Thanks for your input and I appreciate that you did not phrased it as "I disagree with you" :) I don't think I should speculate about your degree of spoiltness (is there such a word?) :)<br/><br/>I *strongly* disagree with the statement &gt;&gt;If someone is as junior to have problems understanding the refactored code, then he should know to shut up&lt;&lt; though. First, I don't think years of experience is any indicator of skill level in itself. Second, effective teams are the ones when there are no (at least technical) unasked questions, and noone has to "just accept" the right way (see also: Cargo Cult). <br/><br/>With regards to easier to understand code - it might be easier for you or for me to understand, but when you've lived with a codebase, you have developed a certain familiarity with it, just like you can almost blindly walk to the newspaper stand on the corner. However, if someone was to alter the pathways, move some billboards around, even if it might be better use of the space, you would first be uncomfortable with it. OK, it's not a perfect analogy, but I hope it conveys my meaning.<br/><br/>We are also missing a lot of context here - e.g.: I likely wouldn't ask my colleagues after a refactoring to see whether it was correct or not, since the tests would catch if I made a mistake. But if there are no test cases, and this code is in a central part of the codebase, I can understand why team members would be worry of the new, untested, unfamiliar code. Also, while I'm not sure how it is on that team, but if someone would respond to me in a way that is described as "willing to put up with my change to shut me up", I would ask myself whether I might be doing something wrong.<br/><br/>And I wouldn't put the kind of description you put into the comments, but rather into testcases :)
</li></ol></li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html">There Is More To Clean Code Than Clean Code</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>On Grassroots/Peer TDD Introduction</title>
      <link>http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html</link>
      <pubDate>Sun, 15 May 2011 14:43:00 CEST</pubDate>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[tdd]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html</guid>
      <description>On Grassroots/Peer TDD Introduction</description>
      <content:encoded><![CDATA[
          
<p>While I'm no trainer/coach, I've been involved in spreading TDD among my peers, with varying extent of success. Recently someone asked for advice on how they should go about it, and in the spirit of <a href="http://sethgodin.typepad.com">Seth Godin</a>, instead of responding in a private email, I wrote this post, a mix of experience and hindsight ideas.</p><br/> <p>So, we are one (or two) developers in the team/company, already sold on TDD, with some unit testing experience. The peers are willing to listen to the concept, and  management, while not willing to invest in formal training, is ok giving a chance, as long as it doesn't hurt the projects' performance. How do we go about it?</p><br/> <h2>Don't introduce TDD on the project</h2><br/> <p>It's common that teams learn/practice new skills on live projects after a basic overview/training. While this might work, I would not recommend this approach for any grassroots initiative, because the chances of failure are significant, and one bad experience with a practice/technology can doom any further attempts to introduce it later, even if not the practice was at fault, only was applied without enough practice. A project manager friend of mine recently complained to me that since the team that worked on a massive legacy project started doing TDD, tasks that used to take hours begun to take days, and clearly, he wasn't happy about that. It turned out that the problem wasn't due to TDD, but lack of discipline (developers went overboard with refactoring, touching parts of the codebase not even remotely connected to the task they've been working on). Despite this, he could have easily come to the conclusion that TDD equals to dropped productivity, without much benefit (bug reports kept coming in, even if for different features - we are talking about legacy code!). Any new skill has a learning curve, you will be slowed down, and you won't get it perfect the first time - don't give a chance for the others to associate failures with the new concept. If you are like me and would need a more concrete example about refactoring just enough, I suggest you read <a href="http://xprogramming.com/">Ron Jeffries</a>' <a href="http://www.amazon.com/Extreme-Programming-Adventures-DV-Microsoft-Professional/dp/0735619492">Extreme Programming Adventures in C#</a> book, and on advice for dealing with legacy code, the undisputed classic book is <a href="http://michaelfeathers.typepad.com/">Michael Feathers</a>' <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a>.</p><br/> <h2>Introducing/selling TDD to the other developers</h2><br/> <p>A lot of technical presentations focus on the <strong>how</strong> instead of <strong>why</strong> it is beneficial to the audience. When it comes to TDD, I would also suggest presenting it simple - skip the emerging design concept (some of the early advocates noted that good design emerging from TDD might had to do with the fact that those early advocates actually had great design sense anyway), don't mention YAGNI - in short, don't overload them with new concepts. I rather liked the approach <a href="http://www.paulbutcher.com/">Paul Butcher</a> took in his <a href="http://pragprog.com/titles/pbdp/debug-it">Debug It!</a> book - we tend to program one baby step at a time, articulating in our mind what the next behavior we'll implement should be, then we code it, and move to the next behavior. TDD (or Test First Development for the nitpickers :)) is just a minor step from that, i.e.: we actually write down the articulated concept in code (which we tend to do anyways with the throwaway main methods used for debugging). And in addition, we get an automated regression test suite for free :). While a live demo could be cool, I would probably show <a href="http://katas.softwarecraftsmanship.org/?p=71">one</a> of the <a href="http://www.katacasts.com/">Kata casts</a> instead of me typing on the projector. Also, be sure to point out that at first we won't be able to code at this speed (I still can't)!</p><br/> <h2>Learning/practice</h2><br/> <p>TDD is a rather simple concept, but so are all the great wisdoms - it takes a lot of time and experience to fully understand those concepts. After the initial TDD sales pitch, I would dedicate a session to going over the tools and the basic usage - how to install the test library, how to run the tests, how to debug a single test, and the basic assert statements - <a href="http://www.nunit.org/index.php?p=equalityAsserts&amp;r=2.5.10">AreEqual</a> vs. <a href="http://www.nunit.org/index.php?p=identityAsserts&amp;r=2.5.10">AreSame</a>, <a href="http://www.nunit.org/index.php?p=exceptionAsserts&amp;r=2.5.10">Assert.Throws</a>, and also an example to show that most likely there are more asserts in the library (e.g. <a href="http://www.nunit.org/index.php?p=stringAssert&amp;r=2.5.10">StringAssert.EndsWith</a>).</p><br/> <p>With those interested/committed, we can move on to the <strong>supervised practice</strong> step. We've worked on <a href="http://codingdojo.org/cgi-bin/wiki.pl?KataCatalogue">simple problems</a>, in a structure inspired by this <a href="http://www.infoq.com/presentations/Building-Good-Habits">Peer learning presentation</a> by <a href="http://www.codemanship.co.uk/">Jason Gorman</a> (his site even has a full <a href="http://www.codemanship.co.uk/sc_at_bbc.pdf">case study</a> of this applied at the BBC). The <a href="http://codingdojo.org/cgi-bin/wiki.pl?WhatIsCodingDojo">coding dojo</a> is another possible format. Important thing is discuss the experiences, lessons learnt, and problems overcome with the whole group, because while practice makes one perfect, bad, practiced habits are hard to unlearn. It is OK not to have all the answers - just be ready to admit it, and ensure that you can find it out from somewhere. Meetups, user groups, and similar forums are invaluably helpful.</p> <br/> <p>Be sure to eat elephant in a piecemeal fashion - while at first the simple problems seem contrived, don't attempt to practice testing existing, complex production code. Stick to the simple problems for practice, every now and then actually demonstrate that it is possibly to test legacy code (though it'll require quite some preparation from you), maybe have some of these examples as a group exercise, but be sure to keep the practice focused on the simple mechanics initially. Just like any sport practice - you repeat rather basic exercises over and over, because it does pay off in the long run, but to keep you motivated, you do have the free practice sessions too.</p><br/> <h2>Don't force it</h2><br/> <p>Not everyone has the same passion as you do (you must have if you read this far :)), and some take a longer time to learn, have different pre-existing concerns they should overcome. Lead by example, be available to talk about it, answer questions, clarify, but don't try to force it on them. Urban cycling didn't became popular because we, cyclists, were preaching to pedestrians and car drivers - we were just approachable to friends, coworkers, etc. and provided answers and listened to their concerns. Yes, it could take a long time, but patience pays off - self-motivated people are more likely to overcome the hurdles they inevitably will face in the learning process!</p><br/> <h2>Bringing it to production</h2><br/> <p>I wouldn't set strong rules or hard deadlines like "two months from now, you all must write all production code in a TDD fashion", but rather just tell people to feel free to experiment during their daily work, but ensure they don't confuse work and practice. If they get stuck on testing some problem, they should just make a note, and deliver the feature untested, as they used to do before. Later, together with the group they should discuss it and potentially find a way to test it.</p><br/> <h2>Further resources</h2><br/> <p>This post is just a high level overview, and I have simply glossed over many of the actual difficulties about writing good unit tests, keeping them maintainable, etc.. There are books written about the topic, in almost all programming languages. Coming from a .NET background, I can recommend <a href="http://www.amazon.com/Art-Unit-Testing-Examples-NET/dp/1933988274/">The Art of Unit Testing with examples in .NET</a> by <a href="http://osherove.com/">Roy Osherov</a>, and I've found <a href="http://jamesshore.com/">James Shore</a>'s <a href="http://jamesshore.com/Blog/Lets-Play/">Let's Play TDD</a> Java episodes great - the best thing about the latter is the thought process narrative that goes with it. <a href="http://pragprog.com/titles/trevan/driving-technical-change">Driving Technical Change</a> might be another good book, though I haven't yet read that.</p><br/> <p>Good luck!</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/18146700402920753476">Miklos</strong></a> on <em>2011/05/16 19:10:12</em>: Thank you for your valuable advice Péter, it will be very useful for our TDD study group. I especially like that you answered in a blog post instead of an email, so other people can also benefit from your answer.
</li><li id="2">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2011/05/16 19:55:11</em>: @Miklos: my pleasure :) Would  be fun to read about your experience (and lessons learned) in a couple of months!
</li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2011/05/on-grassrootspeer-tdd-introduction.html">On Grassroots/Peer TDD Introduction</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
