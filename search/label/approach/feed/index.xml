<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Tue, 19 Apr 2016 10:39:21 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>There Is More To Clean Code Than Clean Code</title>
      <link>http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</link>
      <pubDate>Fri, 03 Feb 2012 20:29:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</guid>
      <description>There Is More To Clean Code Than Clean Code</description>
      <content:encoded><![CDATA[
          
<p><a href="http://blog.8thlight.com/uncle-bob/2012/01/20/Fecophiles.html">A post written by Uncle Bob</a> in January (I'm behind my reading list) offended me. I absolutely agree with Uncle Bob's analysis regarding the code itself, and I also prefer the refactored version, but I have a problem with insulting the programmer(s) reluctant to appreciate the change. </p><br/><p>We write code in programming <em>languages</em>, and there are different levels of proficiency in a language.</p><br/><p>As I'm currently learning a new spoken language, I'm painfully aware of this - initially I probably sounded like a caveman. The first impression you get about me is totally different depending on the language I speak - but I am the same person!</p><br/><p>The learning curve of a language is not smooth - the steepness between consecutive <a href="http://en.wikipedia.org/wiki/Common_European_Framework_of_Reference_for_Languages#Common_reference_levels">levels of proficiency</a> is different. Going from not speaking any German to speaking A1 (tourist) level was easy, getting the basic grammar required for the low intermediate (B1) level wasn't too bad, but to get my German to the level where my English is will take more effort than the sum of all my previous investments<sup>1</sup>.</p><br/><p>Since it is my third foreign language I'm learning, I have no difficulty accepting that the level I think I speak is higher than the level I actually speak. Because of that, whenever someone rephrases my sentences in proper German <sup>2</sup>, I start from the assumption that likely their version is better, even if I don't understand first why - and I take the effort to understand their reasoning <sup>3</sup>. I do that despite that I was of course convinced that when I spoke, I expressed my thoughts in the best possible way.</p><br/><p>However, I don't have much at stake - no ego to hurt, no reputation to loose, and the roles are clear: I'm the beginner, and the people around me are the more experienced ones. In a software team, the roles might not be so clear - I had told colleagues almost twice my age how they should write code after only a few weeks of working there. Bad idea. Since then, I have learned <em>not</em> to start improving the coding style of a team by rewriting the code they have written, and showing off how much better my version is. Rather, I wait until a situation arises when they don't mind having me demonstrate some code improvements. I demo it, and explain why I do it that way. In my experience, the second approach is more effective, though it doesn't have that instant satisfaction and relief the first provides.</p><br/><p>As the joke goes, you need only one psychologist to change a light bulb, but the light bulb has to want the change real bad. </p><br/><p><a href="http://pragprog.com/book/trevan/driving-technical-change">Driving Technical Change</a> is hard, because it requires a mental/cultural change, and that change has to come from the inside - but can be catalyzed from the outside of course<sup>4</sup>. But just forcing practices or ways of working on unwilling recipients generates resistance (e.g.: <a href="http://www.npr.org/blogs/money/2011/12/16/143846133/the-friday-podcast-how-office-politics-could-take-down-europe">the story of the EU technocrat appointed to recalculate the 2009 Greek budget</a>).</p><br/><p>I would like to see more <a href="http://ayende.com/blog/tags/reviews">public code reviews</a> and public refactorings (e.g.: <a href="http://softwarelifecycle.wordpress.com/2012/01/08/an-exercise-in-refactoring/">Andrew Parker</a>, <a href="http://anarchycreek.com/doubledawgdare-series/">GeePawHill</a>), but I would like to see <a href="http://ayende.com/blog/153697/a-meta-post-about-negative-code-reviews">less public judgement passing on people</a> at the lower proficiency levels of programming. </p><br/><hr/><br/><p><sup>1</sup> there is a great <a href="http://hanselminutes.com/301/learning-to-speak-another-language-with-zach-owens">Hanselminutes episode on learning a foreign language</a> if interested. Beware, it may contain programming!</p><br/><p><sup>2</sup> German readers might disagree, since most Germans I meet speak Frankish :)</p><br/><p><sup>3</sup> Which of course, is sometimes harder for natives to properly explain than for novices to ask questions pointing out the seeming irregularities of the grammar</p><br/><p><sup>4</sup> And we won't always be able to foster change in all environments (note: this does not mean the others are at fault for not changing!). The same programmer can be highly productive in one team, and be the one slowing down another team. There is nothing wrong with changing jobs after realizing we are a net loss to a given team.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/06 11:53:39</em>: "I had told colleagues almost twice my age how they should write code after only a few weeks of working there."<br/><br/>Once I did the same: I pointed out that although they wanted to write a super-fast app, writing 500-line long methods just won't work. I also pointed out that having the code polluted with //System.out.println() -s is bad, that they should use some sort of logger instead.<br/><br/>It was pretty obvious to me, even before I read the the Clean Code book. Still, I believe this is why I couldn't get along with the team, and this is why was fired in 2.5 months.<br/><br/>The other side of the coin is: sometimes you just don't want to wait until the bulb wants the change really bad.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/06 20:55:06</em>: Hi bridge,<br/><br/>so I'm not the only one who made that mistake :). And you are right - when there is a culture clash in a team, or we need something other than what's possible (e.g.: we mostly would like to learn from others to improve our tech skills, and not work on our soft skills to be able to teach them our - potentially limited - understanding), moving on to another places probably the best thing - even if on occassion it's a move forced on us!
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/07 10:28:50</em>: Sure, there must be a lot of us who made that mistake :)<br/>On the other hand, I was asked to review their code. But, as it turns out, programmers are almost as sensitive about their code as poets are about their poems.
<ol>
<li id="2-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:18:58</em>: Giving feedback is tricky territory and requires either a built up trust or a lot of discipline from the feedback giver - even if one knows on the analytically that it's about the code, and not about the merits of the coder, a misdirected WTF (e.g.: *Who* wrote this mess?! vs. Look at *what* a mess *this* is.) can push the recipient into the defensive, preventing any positive discussion about *the code*.<br/><br/>Even if we can at least laugh at it (and ourselves), it still hurts - Kyle Baley gives a wonderful description of the feeling at http://codebetter.com/kylebaley/2012/01/30/qa-a-hillbilly-love-story/ :)
</li></ol></li><li id="3">
    <strong><a href="#">r1tch</strong></a> on <em>2012/02/07 14:19:04</em>: I dare to agree with Uncle Bob. :) If someone is as junior to have problems understanding the refactored code, then he should know to shut up. In the story, the two colleagues claimed the original was to be easier to understand! This is obvious bullsh*t. The only thing I might (might!) allow for their help is to add comments in the isPzt() function, explaining what's happening, like:<br/>// an item is PzT if:<br/>// it's non-null, AND<br/>// has parent, AND parent is nfo or discontinued<br/><br/>However, a company is in serious trouble is such comments are needed. Or am I just too spoilt here...? :)
<ol>
<li id="3-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:36:10</em>: Hi r1tch, <br/><br/>Thanks for your input and I appreciate that you did not phrased it as "I disagree with you" :) I don't think I should speculate about your degree of spoiltness (is there such a word?) :)<br/><br/>I *strongly* disagree with the statement &gt;&gt;If someone is as junior to have problems understanding the refactored code, then he should know to shut up&lt;&lt; though. First, I don't think years of experience is any indicator of skill level in itself. Second, effective teams are the ones when there are no (at least technical) unasked questions, and noone has to "just accept" the right way (see also: Cargo Cult). <br/><br/>With regards to easier to understand code - it might be easier for you or for me to understand, but when you've lived with a codebase, you have developed a certain familiarity with it, just like you can almost blindly walk to the newspaper stand on the corner. However, if someone was to alter the pathways, move some billboards around, even if it might be better use of the space, you would first be uncomfortable with it. OK, it's not a perfect analogy, but I hope it conveys my meaning.<br/><br/>We are also missing a lot of context here - e.g.: I likely wouldn't ask my colleagues after a refactoring to see whether it was correct or not, since the tests would catch if I made a mistake. But if there are no test cases, and this code is in a central part of the codebase, I can understand why team members would be worry of the new, untested, unfamiliar code. Also, while I'm not sure how it is on that team, but if someone would respond to me in a way that is described as "willing to put up with my change to shut me up", I would ask myself whether I might be doing something wrong.<br/><br/>And I wouldn't put the kind of description you put into the comments, but rather into testcases :)
</li></ol></li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html">There Is More To Clean Code Than Clean Code</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>Data Migrations As Acceptance Tests</title>
      <link>http://blog.zsoldosp.eu/2011/11/data-migrations-as-acceptance-tests.html</link>
      <pubDate>Fri, 04 Nov 2011 09:23:00 CET</pubDate>
      <category><![CDATA[rewrite]]></category>
      <category><![CDATA[data migration]]></category>
      <category><![CDATA[testing]]></category>
      <category><![CDATA[tdd]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[legacy code]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2011/11/data-migrations-as-acceptance-tests.html</guid>
      <description>Data Migrations As Acceptance Tests</description>
      <content:encoded><![CDATA[
          
<p>While I have previously said that <a href="/2011/09/testing-strategy-on-migration-projects.html">on migration projects both verification and regression tests are important</a>, does it mean that the two should be separate? Like first, let's migrate the data, and then we'll rewrite the functionality, right? Or let's do it the other way around - we'll talk with the customer, incrementally figure out their requirements, deliver the software (with a proper regression test suite) that satisfies them, and then we migrate. Both approaches have problems:</p><br/><ul><br/><li>customers want to use the software with their current, real data - having only the data and no application to use it with is no value to them. Neither is having only an application with no data in it</li><br/><li>real data has lots of surprising scenarios that the domain expert might have forgotten to specify (see <em>caveats</em> though)</li><br/><li>requirements are not static, and new ones will be introduced during the development process, that inevitably will cause the new application's models to change, which means that <a href="http://blog.objectmentor.com/articles/2009/01/09/the-big-redesign-in-the-sky">the migration has a moving target it needs to migrate to</a>. </li><br/></ul><br/><h1>Doing them in parallel</h1><br/><p>If the data source is organized chronologically (<code>order by date</code> in the migration script), and organized in a format that resembles what the system's end users will enter into the system, then we can use the new application's outmost automatable entry point (Selenium, HTTP POST, a module's public API) to enter this data during the migration from the old system to the new.</p><br/><h2>Why</h2><br/><p>While a clear <em>disadvantage of this approach is speed of the migration</em> - it will be likely slower than an <code>INSERT INTO new_db.new_table select .... FROM old_db.old_table join ... where ....</code> statement, but in the case of non-trivial migrations it will likely compensate for the slowness, because:</p><br/><ul><br/><li>changes to the new system's code/data structure become a problem localized to the new application code - no headaches to update the migration scripts <em>in addition to the code</em></li><br/><li>when the client requests the demo deployment to be in sync with the old system, the code is ready (spare for the part to figure out which records have changed)</li><br/><li>the legacy data edge cases provides focus - no need to invent corner cases, for there will be enough in the data</li><br/><li>likely there will be releasable functionality sooner than with either of the above approaches</li><br/></ul><br/><h2>How</h2><br/><p>First, create the acceptance tests for the migration:</p><br/><ul><br/><li>Pick the data to be migrated</li><br/><li>find the view in the original system that displays this data to the users and find a way to extract the data from there</li><br/><li>define the equivalent view in the new system (it's about end to end, user visible features!)</li><br/><li>write the verification script that compares the above two (be sure to list the offending records in the failure message!)</li><br/><li>define the data entry point in the new system</li><br/><li>write the migration script - <em>extract</em> from the old system, <em>transform</em> if needed (only to match the entry points expectations of the format - no quality verification as in <a href="http://en.wikipedia.org/wiki/Extract%2C_transform%2C_load">classic ETL</a>!), then send it into the new system (using the above defined entry point)</li><br/></ul><br/><p>At this point both the new view, and the data entry points are empty. From here on, the <a href="http://pragprog.com/magazines/2011-11/testdriven-development">TDD</a> cycle becomes a nested loop</p><br/><ul><br/><li>run the migration script. See which record it failed for</li><br/><li>analyze the failing acceptance test, and find the missing features for it</li><br/><li><a href="http://gojko.net/FitNesse/book/">(A)TDD</a> the missing features</li><br/><li>run the migration script to restart the cycle</li><br/></ul><br/><h1>Caveats</h1><br/><p>While the existing data makes one focus on the real edge cases instead of the imagined one, beware - not everything has to (or can be) migrated - for instance, in a payment system, the system used to accept many currencies in the past, but now only <em>â‚¬</em>. IN this case, possibly the currency exchange handling logic could be dropped in the new system (and just to store the currency in a char field for the old ones); or in some other domains, maybe only the last ten years' data is needed. However, <em>this should be a business decision</em>, not a decision for a developer!</p><br/><p><em>Source Data Quality</em> is often a problem, one that will likely cause issues. If data needs to be fixed (as above, ask the stakeholders!), it should <em>stay out from your application's code</em>, and be in the <em>Transform</em> part of the migration script.</p>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2011/11/data-migrations-as-acceptance-tests.html">Data Migrations As Acceptance Tests</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
