<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Do. Reflect. Learn. Repeat!</title>
    <link>http://blog.zsoldosp.eu</link>
    <description>Excercises in public learning</description>
    <pubDate>Tue, 19 Apr 2016 10:39:21 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Continuous Team Switching?</title>
      <link>http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</link>
      <pubDate>Sat, 19 Jan 2013 13:35:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html</guid>
      <description>Continuous Team Switching?</description>
      <content:encoded><![CDATA[
          
<a href="http://douglassquirrel.com/">Douglas Squirrel</a> led <a href="http://www.citconf.com/wiki/index.php?title=Continuous_rewriting">a session at CITCON Budapest 2012 about Continuous Rewriting</a>, summarizing many ideas I've heard before from <a href="http://vimeo.com/43659070">Dan North</a> or <a href="http://forwardtechnology.co.uk/videos/32447325">Fred George</a> presentations into a really coherent evolutionary progression,  and took the concept even further. <br/><br/>Like other <em>Continuous</em> practices, this would be as much a  technical as an organizational-cultural change. It got me thinking about how this would change the team dynamics - not just inside a team, but in the context of the bigger organization.<br/><br/>The various <em>Continuous</em> practices always came about the realization that when something is rarely done, people will be bad at it and thus  it will be hard, ineffective and error prone. Thus if we simply do it  more often, we would get better at it.<br/><br/>Joining a new team and becoming an effective contributor is a process that is in need of improvement (on most teams). Getting to grips with the inherent domain complexity and the piled on technical complexity, learning the tricks and workarounds, etc. can hold back someone from being efficient for quite a while. On the other hand, having a fresh set of eyes can provide  a new perspective and expose much of the technical debt the team has.<br/><br/>All the continuous rewrite examples so far have reduced the code size, making it understandable (though often this reduction came thanks to better understanding of the domain).<br/><br/>Assuming the reduced code size enables speedier onboarding of new team members,  while still benefiting from the new perspective it brings, what would  more frequently rotating in and out rotation team members (while never completely  replacing any one team) result in?<br/><ul><li>Could this make spreading of ideas and practices within a company    more effective and faster than the current silo'd, departmental setups?</li><li>Would it speed up the on the job, just in time learning of every<br/>  developer in the company?</li><li>Would it improve the skill level of every developer, or would it   drag everyone down?</li><li>Would it strengthen the company culture, simply since each person    would know more other employees (given that many of us only socialize    within our own team)? </li><li>Would it spark more cross-departmental improvements - unlike    accountants or marketers, developers can jump between various areas    and domains of the company with relative ease, and thus could see    potential improvements. Would this make crazy IT processes (where the data   passes through, without enhancement, several different teams and applications,   modified effectively by only one at the middle, then be loaded back into    the original source) extinct, making IT governance easier?</li></ul>I don't know. But it certainly was a fun thought experiment! Feel free to add questions to the above list in the comments!
<hr><ol>
<li id="1">
    <strong><a href="http://www.odd-e.com">Steven</strong></a> on <em>2013/01/19 15:42:41</em>: There are studies found that stable teams can improve as long as 3 years. From that I would recommend stable teams over switching team members in and out.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/19 17:08:12</em>: Steve,<br/><br/>thanks for the input! Could you give some pointers for these studies (titles or links)?<br/><br/>I don't understand your second sentence (not a native English speaker) - you suggest that based on these studies, having a stable team is better/more effective/etc. than having constantly changing team members (the thought experiment of this post)?
</li></ol></li><li id="2">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/21 21:22:23</em>: Wow, this makes sense.<br/><br/>Let me add some anecdotal evidence: Every time I'm joining a team, I start to see tons of technical debt. Later I'm getting used to it. Sometimes I even miss the old code when switching to something new. This is the thing that makes _some_ outsourcing veterans (i.e. EPAM alumni) very efficient.
</li><li id="3">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2013/01/23 20:38:18</em>: what is the thing that makes outsourcing veterans efficient? The ability to enter any codebase and identify the place(s) that need changing for the new feature/project? <br/><br/>To add to the anecdotes (hoping @jasongorman doesn't read comments :)) - you don't need outsourcing for that, enough if you work on maintenance teams that are responsible for more than one application. Though it might be more a question of attitude and/or confidence than experience with switches. E.g.: I never hesitate to follow a stacktrace into 3rd party code (or find out why I *don't* have a stacktrace) or simply load the source to compensate the unhelpful documentation. Kind of like the difference between junior and senior developers is that the latter are not afraid to voice their opinions/questions...
</li><li id="4">
    <strong><a href="http://tamasrev.wordpress.com/">tamasrev</strong></a> on <em>2013/01/29 19:37:44</em>: Didn't the blog just swallowed my comment? Here it is again:<br/><br/>What makes outsourcing veterans very efficient that they have to work with and maintain several projects written by other people. They will learn both continuously improve the code as well as do fuckin quick fixes. They also learn how to adapt to different coding styles they see in their project pool. They can relatively quickly identify the problematic parts of a codebase and they can come up with change suggestions. However, a typical outsourcing consumer isn't interested in their opinion.<br/><br/>It's worth to mention that outsourcing veterans only have a *chance* to learn all this stuff. They can also burn out due to the mind-numbing tasks they have to do.
</li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2013/01/continuous-team-switching.html">Continuous Team Switching?</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>There Is More To Clean Code Than Clean Code</title>
      <link>http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</link>
      <pubDate>Fri, 03 Feb 2012 20:29:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[team]]></category>
      <category><![CDATA[teaching]]></category>
      <category><![CDATA[approach]]></category>
      <category><![CDATA[change]]></category>
      <category><![CDATA[software]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html</guid>
      <description>There Is More To Clean Code Than Clean Code</description>
      <content:encoded><![CDATA[
          
<p><a href="http://blog.8thlight.com/uncle-bob/2012/01/20/Fecophiles.html">A post written by Uncle Bob</a> in January (I'm behind my reading list) offended me. I absolutely agree with Uncle Bob's analysis regarding the code itself, and I also prefer the refactored version, but I have a problem with insulting the programmer(s) reluctant to appreciate the change. </p><br/><p>We write code in programming <em>languages</em>, and there are different levels of proficiency in a language.</p><br/><p>As I'm currently learning a new spoken language, I'm painfully aware of this - initially I probably sounded like a caveman. The first impression you get about me is totally different depending on the language I speak - but I am the same person!</p><br/><p>The learning curve of a language is not smooth - the steepness between consecutive <a href="http://en.wikipedia.org/wiki/Common_European_Framework_of_Reference_for_Languages#Common_reference_levels">levels of proficiency</a> is different. Going from not speaking any German to speaking A1 (tourist) level was easy, getting the basic grammar required for the low intermediate (B1) level wasn't too bad, but to get my German to the level where my English is will take more effort than the sum of all my previous investments<sup>1</sup>.</p><br/><p>Since it is my third foreign language I'm learning, I have no difficulty accepting that the level I think I speak is higher than the level I actually speak. Because of that, whenever someone rephrases my sentences in proper German <sup>2</sup>, I start from the assumption that likely their version is better, even if I don't understand first why - and I take the effort to understand their reasoning <sup>3</sup>. I do that despite that I was of course convinced that when I spoke, I expressed my thoughts in the best possible way.</p><br/><p>However, I don't have much at stake - no ego to hurt, no reputation to loose, and the roles are clear: I'm the beginner, and the people around me are the more experienced ones. In a software team, the roles might not be so clear - I had told colleagues almost twice my age how they should write code after only a few weeks of working there. Bad idea. Since then, I have learned <em>not</em> to start improving the coding style of a team by rewriting the code they have written, and showing off how much better my version is. Rather, I wait until a situation arises when they don't mind having me demonstrate some code improvements. I demo it, and explain why I do it that way. In my experience, the second approach is more effective, though it doesn't have that instant satisfaction and relief the first provides.</p><br/><p>As the joke goes, you need only one psychologist to change a light bulb, but the light bulb has to want the change real bad. </p><br/><p><a href="http://pragprog.com/book/trevan/driving-technical-change">Driving Technical Change</a> is hard, because it requires a mental/cultural change, and that change has to come from the inside - but can be catalyzed from the outside of course<sup>4</sup>. But just forcing practices or ways of working on unwilling recipients generates resistance (e.g.: <a href="http://www.npr.org/blogs/money/2011/12/16/143846133/the-friday-podcast-how-office-politics-could-take-down-europe">the story of the EU technocrat appointed to recalculate the 2009 Greek budget</a>).</p><br/><p>I would like to see more <a href="http://ayende.com/blog/tags/reviews">public code reviews</a> and public refactorings (e.g.: <a href="http://softwarelifecycle.wordpress.com/2012/01/08/an-exercise-in-refactoring/">Andrew Parker</a>, <a href="http://anarchycreek.com/doubledawgdare-series/">GeePawHill</a>), but I would like to see <a href="http://ayende.com/blog/153697/a-meta-post-about-negative-code-reviews">less public judgement passing on people</a> at the lower proficiency levels of programming. </p><br/><hr/><br/><p><sup>1</sup> there is a great <a href="http://hanselminutes.com/301/learning-to-speak-another-language-with-zach-owens">Hanselminutes episode on learning a foreign language</a> if interested. Beware, it may contain programming!</p><br/><p><sup>2</sup> German readers might disagree, since most Germans I meet speak Frankish :)</p><br/><p><sup>3</sup> Which of course, is sometimes harder for natives to properly explain than for novices to ask questions pointing out the seeming irregularities of the grammar</p><br/><p><sup>4</sup> And we won't always be able to foster change in all environments (note: this does not mean the others are at fault for not changing!). The same programmer can be highly productive in one team, and be the one slowing down another team. There is nothing wrong with changing jobs after realizing we are a net loss to a given team.</p>
<hr><ol>
<li id="1">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/06 11:53:39</em>: "I had told colleagues almost twice my age how they should write code after only a few weeks of working there."<br/><br/>Once I did the same: I pointed out that although they wanted to write a super-fast app, writing 500-line long methods just won't work. I also pointed out that having the code polluted with //System.out.println() -s is bad, that they should use some sort of logger instead.<br/><br/>It was pretty obvious to me, even before I read the the Clean Code book. Still, I believe this is why I couldn't get along with the team, and this is why was fired in 2.5 months.<br/><br/>The other side of the coin is: sometimes you just don't want to wait until the bulb wants the change really bad.
<ol>
<li id="1-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/06 20:55:06</em>: Hi bridge,<br/><br/>so I'm not the only one who made that mistake :). And you are right - when there is a culture clash in a team, or we need something other than what's possible (e.g.: we mostly would like to learn from others to improve our tech skills, and not work on our soft skills to be able to teach them our - potentially limited - understanding), moving on to another places probably the best thing - even if on occassion it's a move forced on us!
</li></ol></li><li id="2">
    <strong><a href="http://www.blogger.com/profile/06859781419645954688">bridge</strong></a> on <em>2012/02/07 10:28:50</em>: Sure, there must be a lot of us who made that mistake :)<br/>On the other hand, I was asked to review their code. But, as it turns out, programmers are almost as sensitive about their code as poets are about their poems.
<ol>
<li id="2-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:18:58</em>: Giving feedback is tricky territory and requires either a built up trust or a lot of discipline from the feedback giver - even if one knows on the analytically that it's about the code, and not about the merits of the coder, a misdirected WTF (e.g.: *Who* wrote this mess?! vs. Look at *what* a mess *this* is.) can push the recipient into the defensive, preventing any positive discussion about *the code*.<br/><br/>Even if we can at least laugh at it (and ourselves), it still hurts - Kyle Baley gives a wonderful description of the feeling at http://codebetter.com/kylebaley/2012/01/30/qa-a-hillbilly-love-story/ :)
</li></ol></li><li id="3">
    <strong><a href="#">r1tch</strong></a> on <em>2012/02/07 14:19:04</em>: I dare to agree with Uncle Bob. :) If someone is as junior to have problems understanding the refactored code, then he should know to shut up. In the story, the two colleagues claimed the original was to be easier to understand! This is obvious bullsh*t. The only thing I might (might!) allow for their help is to add comments in the isPzt() function, explaining what's happening, like:<br/>// an item is PzT if:<br/>// it's non-null, AND<br/>// has parent, AND parent is nfo or discontinued<br/><br/>However, a company is in serious trouble is such comments are needed. Or am I just too spoilt here...? :)
<ol>
<li id="3-1">
    <strong><a href="/">Peter Zsoldos</strong></a> on <em>2012/02/07 19:36:10</em>: Hi r1tch, <br/><br/>Thanks for your input and I appreciate that you did not phrased it as "I disagree with you" :) I don't think I should speculate about your degree of spoiltness (is there such a word?) :)<br/><br/>I *strongly* disagree with the statement &gt;&gt;If someone is as junior to have problems understanding the refactored code, then he should know to shut up&lt;&lt; though. First, I don't think years of experience is any indicator of skill level in itself. Second, effective teams are the ones when there are no (at least technical) unasked questions, and noone has to "just accept" the right way (see also: Cargo Cult). <br/><br/>With regards to easier to understand code - it might be easier for you or for me to understand, but when you've lived with a codebase, you have developed a certain familiarity with it, just like you can almost blindly walk to the newspaper stand on the corner. However, if someone was to alter the pathways, move some billboards around, even if it might be better use of the space, you would first be uncomfortable with it. OK, it's not a perfect analogy, but I hope it conveys my meaning.<br/><br/>We are also missing a lot of context here - e.g.: I likely wouldn't ask my colleagues after a refactoring to see whether it was correct or not, since the tests would catch if I made a mistake. But if there are no test cases, and this code is in a central part of the codebase, I can understand why team members would be worry of the new, untested, unfamiliar code. Also, while I'm not sure how it is on that team, but if someone would respond to me in a way that is described as "willing to put up with my change to shut me up", I would ask myself whether I might be doing something wrong.<br/><br/>And I wouldn't put the kind of description you put into the comments, but rather into testcases :)
</li></ol></li></ol>

          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2012/02/there-is-more-to-clean-code-than-clean.html">There Is More To Clean Code Than Clean Code</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
    <item>
      <title>When in Rome, do as the Romans do</title>
      <link>http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</link>
      <pubDate>Fri, 03 Dec 2010 08:30:00 CET</pubDate>
      <category><![CDATA[culture]]></category>
      <category><![CDATA[software]]></category>
      <category><![CDATA[programming languages]]></category>
      <guid isPermaLink="false">http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html</guid>
      <description>When in Rome, do as the Romans do</description>
      <content:encoded><![CDATA[
          
<div><div><a href="http://www.pragprog.com/the-pragmatic-programmer">The Pragmatic Programmer</a> gives a very popular advice: <a href="http://stackoverflow.com/questions/1003940/learn-a-new-language-every-year">learn a new language every year</a>. The main reason behind this advice is that when you learn a new language, you learn a new way to think. </div><div><br/></div><div>However, especially when getting started with a new one, we (inadvertently) try to understand it by comparing it to something we already know, which is likely the language we are most comfortable with, thus turning the learning experience into a square peg-round hole problem. Be aware of of this limitation before dismissing a language or a language feature as something horrible.</div><div><br/></div><div>Some easy to spot examples of mistakes I have seen myself and/or others make are:</div><div><ul><li>creating lots of simple DTO classes in Python instead of using tuples </li><li>trying to create a synchronous API for a web service call in Flex</li><li>creating an indexer for the immutable list in Scala</li><li>...</li><li>...and of course, procedural PL/SQL code with lot's of loops and ifs instead of set based operations</li></ul></div><div>The subtle differences (idioms) can be trickier, but are worthy to learn about. Similar operations can behave surprisingly differently in different languages. When splitting a collection in C#, asking for an invalid slice range, you get an IndexOutOfRangeException, while in a functional language you likely get an empty list as the result.  In Python it's  called <i>monkey patching</i>, while ruby people call that <i>opening up a class</i>. </div><div><br/></div><div>Even a seasoned programmer picking up a new language misses these  - so if you can get someone to review your code in such detail as it's been done for <a href="http://bestinclass.dk/index.clj/2010/10/taking-uncle-bob-to-school.html">Uncle Bob in Clojure</a> or <a href="http://davybrion.com/blog/2010/08/using-more-rubyesq-events-in-ruby/">Davy Brion in Ruby</a>, do yourself a favor, and ask for it!</div><div><br/></div><div>If you are afraid of learning in public, and don't have access to experienced mentors, <a href="http://www.hanselman.com/blog/TheWeeklySourceCode1.aspx">read code</a>, and try to understand unreadable-at-first bits - I have fond memories of the time we have tried figuring out what (and why) some method did in <a href="http://code.google.com/p/scalacheck/">scalacheck</a>.</div><div><br/></div><div>Note that I'm not saying you should not <a href="http://thisdeveloperslife.com/post/1620026288/1-0-8-motivation">innovate</a>, there have been (and will be!) great things coming out of concepts moving between platforms - boy I'm glad for NHibernate, and annotation based test methods coming from NUnit to JUnit were quite welcome too. However, first understand the platform's own means to the given end before deciding you need something from another platform. </div><div><br/></div><div>So <a href="http://phpadvent.org/2008/php-is-not-java-by-luke-welling">embrace the culture of the language</a>, and if you feel you are not learning something new in the new language, don't rest, but seek out those differences that surely are there under the hood! </div><div><br/></div><div>Happy learning, dear reader!</div></div>
          <hr />
          The post <a hef="http://blog.zsoldosp.eu/2010/12/when-in-rome-do-as-romans-do.html">When in Rome, do as the Romans do</a> first appeared on <a href="http://blog.zsoldosp.eu">http://blog.zsoldosp.eu</a>.
        ]]></content:encoded>
    </item>
  </channel>
</rss>
